=== Begin ./test-bin/array_adaptive1 ===
Program 1: forall 0<= i< 10. a[i] = 123456
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, 10]; A0.smashed -> [0, 123456]})
bb1_f=({}, {i -> [0, 10]; A0.smashed -> [0, 123456]})
ret=({}, {i -> [10, 10]; A0.smashed -> [0, 123456]})
bb1_t=({}, {i -> [0, 10]; A0.smashed -> [0, 123456]})
bb2=({}, {i -> [0, 9]; A0.smashed -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, 10]; A.smashed -> [0, 123456]; B.smashed -> [0, 123456]})
bb1_f=({}, {i -> [0, 10]; A.smashed -> [0, 123456]; B.smashed -> [0, 123456]})
ret=({}, {i -> [10, 10]; A.smashed -> [0, 123456]; B.smashed -> [0, 123456]})
bb1_t=({}, {i -> [0, 10]; A.smashed -> [0, 123456]; B.smashed -> [0, 123456]})
bb2=({}, {i -> [0, 9]; A.smashed -> [0, 123456]; B.smashed -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, 10]; A.smashed -> [0, 8]; B.smashed -> [0, 5]})
bb1_f=({}, {i -> [0, 10]; A.smashed -> [0, 8]; B.smashed -> [0, 5]})
ret=({}, {i -> [10, 10]; A.smashed -> [0, 8]; B.smashed -> [0, 5]})
bb1_t=({}, {i -> [0, 10]; A.smashed -> [0, 8]; B.smashed -> [0, 5]})
bb2=({}, {i -> [0, 9]; A.smashed -> [0, 8]; B.smashed -> [0, 5]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, +oo]; n -> [1, +oo]})
bb1_f=({}, {i -> [0, +oo]; n -> [1, +oo]})
ret=({}, {i -> [1, +oo]; n -> [1, +oo]})
bb1_t=({}, {i -> [0, +oo]; n -> [1, +oo]})
bb2=({}, {i -> [0, +oo]; n -> [1, +oo]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 5: for all 0<= i< 10. a[i] = 123456 (assume elem size=4 bytes)
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, 10]; A.smashed -> [0, 123456]})
bb1_f=({}, {i -> [0, 10]; A.smashed -> [0, 123456]})
ret=({}, {i -> [10, 10]; A.smashed -> [0, 123456]})
bb1_t=({}, {i -> [0, 10]; A.smashed -> [0, 123456]})
bb2=({}, {i -> [0, 9]; A.smashed -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [1, +oo]; n -> [2, +oo]; val -> [89, 89]})
bb1_f=({}, {i -> [1, +oo]; n -> [2, +oo]; val -> [89, 89]})
ret=({}, {i -> [2, +oo]; n -> [2, +oo]; val -> [89, 89]})
bb1_t=({}, {i -> [1, +oo]; n -> [2, +oo]; val -> [89, 89]})
bb2=({}, {i -> [1, +oo]; n -> [2, +oo]; val -> [89, 89]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, 11]; n -> [1, +oo]; A.smashed -> [0, 123456]})
bb1_f=({}, {i -> [0, 11]; n -> [1, +oo]; A.smashed -> [0, 123456]})
ret=({}, {i -> [10, 11]; n -> [1, +oo]; A.smashed -> [0, 123456]})
bb1_t=({}, {i -> [0, 11]; n -> [1, +oo]; A.smashed -> [0, 123456]})
bb2=({}, {i -> [0, 9]; n -> [1, +oo]; A.smashed -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb1_f2=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb1_f=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
ret=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb1_f1=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb1_t=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb2=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb2b=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
bb2a=({}, {i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]})
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [-1, 9]; A.smashed -> [0, 123456]})
bb1_f=({}, {i -> [-1, 9]; A.smashed -> [0, 123456]})
ret=({}, {i -> [-1, -1]; A.smashed -> [0, 123456]})
bb1_t=({}, {i -> [-1, 9]; A.smashed -> [0, 123456]})
bb2=({}, {i -> [0, 9]; A.smashed -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 11: forall 0<= i< 10. a[i] = true and b[i] = false
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {i -> [0, 10]})
bb1_f=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {i -> [0, 10]})
ret=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {i -> [10, 10]})
bb1_t=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {i -> [0, 10]})
bb2=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {i -> [0, 9]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

=== End ./test-bin/array_adaptive1 ===
=== Begin ./test-bin/array_adaptive2 ===
===================================
 Test 1 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0 bb2 bb1 bb3
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 2 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0 bb2 bb1 bb3
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 3 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0 bb2 bb1 bb3
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
4  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 4 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 5 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 6 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 7 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: entry ret
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 8 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: entry ret
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 9 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: entry ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 10 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0 bb2 bb1 bb3 bb4
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 11 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0 bb2 bb1 bb3 bb4
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 12 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0
user-defined assertion checker
4  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 13 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
Abstract trace: bb0
user-defined assertion checker
5  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/array_adaptive2 ===
=== Begin ./test-bin/array_smashing ===
Program 1: forall 0<= i< 10. a[i] = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A0_prop -> [0, 0]; A0.smashed -> [0, 0] | [123456, 123456]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A0_prop -> [0, 0]; A0.smashed -> [0, 0] | [123456, 123456]}
ret={n1 -> [1, 1]; i -> [10, 10]; A0_prop -> [0, 0]; A0.smashed -> [0, 0] | [123456, 123456]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A0_prop -> [0, 0]; A0.smashed -> [0, 0] | [123456, 123456]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A0_prop -> [0, 0]; A0.smashed -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A0_prop -> [0, 0], A0.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A0.smashed-i<=123455}
bb1_f={n1 -> [1, 1], i -> [0, 10], A0_prop -> [0, 0], A0.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A0.smashed-i<=123455}
ret={n1 -> [1, 1], i -> [10, 10], A0_prop -> [0, 0], A0.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A0.smashed-i<=123455}
bb1_t={n1 -> [1, 1], i -> [0, 10], A0_prop -> [0, 0], A0.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A0.smashed-i<=123455}
bb2={n1 -> [1, 1], i -> [0, 9], A0_prop -> [0, 0], A0.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A0.smashed-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]; B.smashed -> [0, 0] | [123456, 123456]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]; B.smashed -> [0, 0] | [123456, 123456]}
ret={n1 -> [1, 1]; i -> [10, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]; B.smashed -> [0, 0] | [123456, 123456]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]; B.smashed -> [0, 0] | [123456, 123456]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]; B.smashed -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 123456], B.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A.smashed-i<=123455, B.smashed-i<=123455}
bb1_f={n1 -> [1, 1], i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 123456], B.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A.smashed-i<=123455, B.smashed-i<=123455}
ret={n1 -> [1, 1], i -> [10, 10], A_p -> [0, 0], A.smashed -> [0, 123456], B.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A.smashed-i<=123455, B.smashed-i<=123455}
bb1_t={n1 -> [1, 1], i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 123456], B.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A.smashed-i<=123455, B.smashed-i<=123455}
bb2={n1 -> [1, 1], i -> [0, 9], A_p -> [0, 0], A.smashed -> [0, 123456], B.smashed -> [0, 123456], i-n1<=9, n1-i<=1, A.smashed-i<=123455, B.smashed-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [8, 8]; B.smashed -> [0, 0] | [5, 5]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [8, 8]; B.smashed -> [0, 0] | [5, 5]}
ret={n1 -> [1, 1]; i -> [10, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [8, 8]; B.smashed -> [0, 0] | [5, 5]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [8, 8]; B.smashed -> [0, 0] | [5, 5]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [8, 8]; B.smashed -> [0, 0] | [5, 5]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 8], B.smashed -> [0, 5], i-n1<=9, n1-i<=1, A.smashed-i<=7, B.smashed-i<=4}
bb1_f={n1 -> [1, 1], i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 8], B.smashed -> [0, 5], i-n1<=9, n1-i<=1, A.smashed-i<=7, B.smashed-i<=4}
ret={n1 -> [1, 1], i -> [10, 10], A_p -> [0, 0], A.smashed -> [0, 8], B.smashed -> [0, 5], i-n1<=9, n1-i<=1, A.smashed-i<=7, B.smashed-i<=4}
bb1_t={n1 -> [1, 1], i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 8], B.smashed -> [0, 5], i-n1<=9, n1-i<=1, A.smashed-i<=7, B.smashed-i<=4}
bb2={n1 -> [1, 1], i -> [0, 9], A_p -> [0, 0], A.smashed -> [0, 8], B.smashed -> [0, 5], i-n1<=9, n1-i<=1, A.smashed-i<=7, B.smashed-i<=4}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_f={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
ret={n1 -> [1, 1]; i -> [1, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_t={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb2={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], n1-i<=1, A.smashed-i<=123455, i-n<=0, A.smashed-n<=123455}
bb1_f={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], n1-i<=1, A.smashed-i<=123455, i-n<=0, A.smashed-n<=123455}
ret={n1 -> [1, 1], i -> [1, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], n1-i<=1, A.smashed-i<=123455, n-i<=0, i-n<=0, A.smashed-n<=123455}
bb1_t={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], n1-i<=1, A.smashed-i<=123455, i-n<=0, A.smashed-n<=123455}
bb2={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], n1-i<=1, A.smashed-i<=123455, i-n<=-1, A.smashed-n<=123454, n1-n<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 5: for all 0<= i< 10. a[i] = 123456 (assume elem size of 4 bytes)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_f={i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
ret={i -> [10, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_t={i -> [0, 10]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb2={i -> [0, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 123456], A.smashed-i<=123455}
bb1_f={i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 123456], A.smashed-i<=123455}
ret={i -> [10, 10], A_p -> [0, 0], A.smashed -> [0, 123456], A.smashed-i<=123455}
bb1_t={i -> [0, 10], A_p -> [0, 0], A.smashed -> [0, 123456], A.smashed-i<=123455}
bb2={i -> [0, 9], A_p -> [0, 0], A.smashed -> [0, 123456], A.smashed-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]; A.smashed -> [0, 0] | [89, 89]}
bb1_f={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]; A.smashed -> [0, 0] | [89, 89]}
ret={n1 -> [1, 1]; i -> [2, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]; A.smashed -> [0, 0] | [89, 89]}
bb1_t={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]; A.smashed -> [0, 0] | [89, 89]}
bb2={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]; A.smashed -> [0, 0] | [89, 89]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A_p -> [0, 0], val -> [89, 89], A.smashed -> [0, 89], n1-i<=0, i-n<=0}
bb1_f={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A_p -> [0, 0], val -> [89, 89], A.smashed -> [0, 89], n1-i<=0, i-n<=0}
ret={n1 -> [1, 1], i -> [2, +oo], n -> [2, +oo], A_p -> [0, 0], val -> [89, 89], A.smashed -> [0, 89], n1-i<=0, n-i<=0, i-n<=0}
bb1_t={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A_p -> [0, 0], val -> [89, 89], A.smashed -> [0, 89], n1-i<=0, i-n<=0}
bb2={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A_p -> [0, 0], val -> [89, 89], A.smashed -> [0, 89], n1-i<=0, i-n<=-1, n1-n<=-1}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_f={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
ret={n1 -> [1, 1]; n2 -> [2, 2]; i -> [10, 11]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_t={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb2={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 9]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], i-n2<=9, n2-i<=2, A.smashed-i<=123454}
bb1_f={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], i-n2<=9, n2-i<=2, A.smashed-i<=123454}
ret={n1 -> [1, 1], n2 -> [2, 2], i -> [10, 11], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], i-n2<=9, n2-i<=2, A.smashed-i<=123454}
bb1_t={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], i-n2<=9, n2-i<=2, A.smashed-i<=123454}
bb2={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 9], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 123456], i-n2<=9, n2-i<=2, A.smashed-i<=123454}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb1_f2={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb1_f={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
ret={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb1_f1={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb1_t={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb2={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb2b={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
bb2a={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]; A.smashed -> [0, 2]}
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=0, A.smashed-n<=1, i2-n<=0, n1-n<=0}
bb1_f2={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=0, A.smashed-n<=1, i2-n<=0, n1-n<=0}
bb1_f={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=0, A.smashed-n<=1, i2-n<=0, n1-n<=0}
ret={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=0, A.smashed-n<=1, i2-n<=0, n1-n<=0}
bb1_f1={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=0, A.smashed-n<=1, i2-n<=0, n1-n<=0}
bb1_t={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=0, A.smashed-n<=1, i2-n<=0, n1-n<=0}
bb2={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=-1, A.smashed-n<=0, i2-n<=-1, n1-n<=0}
bb2b={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=-1, A.smashed-n<=0, i2-n<=-1, n1-n<=0}
bb2a={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A_p -> [0, 0], A.smashed -> [0, 2], n1-i1<=1, A.smashed-i1<=2, A.smashed-i2<=1, n1-i2<=1, i1-n<=-1, A.smashed-n<=0, i2-n<=-1, n1-n<=0}
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_f={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
ret={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, -1]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb1_t={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
bb2={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [0, 9]; A_p -> [0, 0]; A.smashed -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A_p -> [0, 0], A.smashed -> [0, 123456]}
bb1_f={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A_p -> [0, 0], A.smashed -> [0, 123456]}
ret={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, -1], A_p -> [0, 0], A.smashed -> [0, 123456]}
bb1_t={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A_p -> [0, 0], A.smashed -> [0, 123456]}
bb2={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [0, 9], A_p -> [0, 0], A.smashed -> [0, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 10: forall 0<= i< 10. a[i] = true and b[i] = false
Invariants using ArraySmashing(Product(Boolean,SparseDBM))
entry=({}, {})
bb1=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
bb1_f=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
ret=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=-9})
bb1_t=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
bb2=({TRUE -> true; FALSE -> false; A.smashed -> true; B.smashed -> false}, {n1 -> [1, 1], i -> [0, 9], i-n1<=8, n1-i<=1})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

=== End ./test-bin/array_smashing ===
=== Begin ./test-bin/backward-array-1 ===
entry:
  x = array_load(M,0,sz=4);
  goto bb1,bb2;
bb1:
  assume(-x <= 0);
  array_store(M,4,x,sz=4);
  goto bb3;
bb3:
  y = array_load(M,4,sz=4);
  assume(-y <= -1);
  assert(x != 0);

bb2:
  assume(x <= -1);
  tmp = 0;
  y = tmp-x;
  array_store(M,4,y,sz=4);
  goto bb3;

Invariants using ArrayAdaptive(ArraySmashing(Intervals))
entry={}
bb2={}
bb3={M[4...7] -> [0, +oo]}
bb1={}
 --- SAFE --------------------
Property : x != 0
Invariant: {y -> [1, +oo]; M[4...7] -> [0, +oo]}
Note: it was proven by the forward+backward analysis
 -----------------------------
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/backward-array-1 ===
=== Begin ./test-bin/bu_inter ===
z:int32 declare foo(x:int32)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;


y1:int32 declare bar(a:int32)
entry:
  x1 = a;
  w1 = 5;
  goto exit;
exit:
  y1:int32 = call foo(x1:int32);


t:int32 declare rec1(s:int32)
entry:
  r = s-1;
  goto exit;
exit:
  t:int32 = call rec2(r:int32);


t1:int32 declare rec2(s1:int32)
entry:
  r1 = s1-1;
  goto exit;
exit:
  t1:int32 = call rec1(r1:int32);


w2:int32 declare main()
entry:
  x2 = 3;
  y2:int32 = call bar(x2:int32);
  z3:int32 = call rec1(y2:int32);
  goto exit;
exit:
  z2 = y2+2;
  w2:int32 = call foo(z2:int32);


Running summary domain=SparseDBM and forward domain=Intervals
z:int32 declare foo(x:int32)
exit={x -> [3, 8]; y -> [4, 9]; z -> [6, 11]}
entry={x -> [3, 8]; y -> [4, 9]}
=================================
y1:int32 declare bar(a:int32)
exit={a -> [3, 3]; x1 -> [3, 3]; y1 -> [6, 6]; w1 -> [5, 5]}
entry={a -> [3, 3]; x1 -> [3, 3]; w1 -> [5, 5]}
=================================
t:int32 declare rec1(s:int32)
exit={}
entry={}
=================================
t1:int32 declare rec2(s1:int32)
exit={}
entry={}
=================================
w2:int32 declare main()
exit={x2 -> [3, 3]; y2 -> [6, 6]; z2 -> [8, 8]; w2 -> [11, 11]}
entry={x2 -> [3, 3]; y2 -> [6, 6]}
=================================
=== End ./test-bin/bu_inter ===
=== Begin ./test-bin/cfg ===
CFG
x0:
  k = 2147483648;
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Reversed CFG
ret:
--> [bb1_f;]
bb1_f:
  assume(-i <= -100);
--> [bb1;]
bb1:
--> [entry;bb2;]
entry:
  i = 0;
--> [x3;]
x3:
--> [x2;]
x2:
--> [x1;]
x1:
--> [x0;]
x0:
  k = 2147483648;
--> []
bb2:
  i = i+inc;
  inc = ite(-nd <= -1,1,2);
  havoc(nd);
--> [bb1_t;]
bb1_t:
  assume(i <= 99);
--> [bb1;]

Weak reversed topological order of CFG 
ret -- bb1_f -- bb2 -- bb1_t -- bb1 -- entry -- x3 -- x2 -- x1 -- x0
Weak topological order of the reversed CFG 
ret -- bb1_f -- bb1 -- bb2 -- bb1_t -- entry -- x3 -- x2 -- x1 -- x0
Bourdoncle WTO of the reversed CFG
ret bb1_f (bb1 bb2 bb1_t) entry x3 x2 x1 x0
Simplified CFG
x0:
  k = 2147483648;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Reversed simplified CFG
ret:
--> [bb1_f;]
bb1_f:
  assume(-i <= -100);
--> [bb1;]
bb1:
--> [x0;bb1_t;]
x0:
  i = 0;
  k = 2147483648;
--> []
bb1_t:
  i = i+inc;
  inc = ite(-nd <= -1,1,2);
  havoc(nd);
  assume(i <= 99);
--> [bb1;]

CFG
entry:
  goto x1;
x1:
  goto x2,x6,exit;
x2:
  goto x3,x4;
x3:
  goto x5;
x5:
  goto x1;
x4:
  goto x5;
x6:
  goto x7,x8;
x7:
  goto x9;
x9:
  goto exit;
exit:

x8:
  goto x9;

Control-dependence graph 
{x2;x5;x6;x9;}  control-dependent on x1
{x3;x4;}  control-dependent on x2
{x7;x8;}  control-dependent on x6
=== End ./test-bin/cfg ===
=== Begin ./test-bin/cg ===
w:int32 declare foo(x:int32)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;
  w:int32 = call barz(z:int32);


y:int32 declare bar(a:int32)
entry:
  x = a;
  goto exit;
exit:
  y:int32 = call foo(x:int32);


void declare main()
entry:
  x = 3;
  y:int32 = call bar(x:int32);
  goto exit;
exit:
  z = y+2;


bar--> foo
main--> bar

number of predecessors foo=1
bar-->foo
number of successors bar=1
bar-->foo
number of predecessors bar=1
main-->bar
number of successors main=1
main-->bar
Found root main
Printing in preorder ...
main
bar
foo
reverse topological sort: foo--bar--main--
topological sort: main--bar--foo--
Callgraph=
foo--> barz
bar--> foo
main--> bar
barz--> bar

Weak topological ordering=main (bar foo barz)
=== End ./test-bin/cg ===
=== Begin ./test-bin/checker ===

Assertion Crawler Analysis 
entry={"assert(-x <= -200)" -> {}; "assert(-x+y <= 0)" -> {}; "assert(-i <= -200)" -> {}; "assert(i = 100)" -> {}}
bb1={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb1_f={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
ret={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb1_t={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb2={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}


******* UNJUSTIFIED ASSUMPTION ANALYSIS ********
assert(-i <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a3 in x = x+y
	assume NotOverflow({y}) as a4 in y = y+1
	assume NotOverflow({i}) as a5 in i = i+1
assert(-x <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a9 in x = x+y
	assume NotOverflow({y}) as a10 in y = y+1
	assume NotOverflow({i}) as a11 in i = i+1
assert(-x+y <= 0) with unjustified assumptions:
	assume NotOverflow({x; y}) as a6 in x = x+y
	assume NotOverflow({y}) as a7 in y = y+1
	assume NotOverflow({i}) as a8 in i = i+1
assert(i = 100) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
	assume NotOverflow({i}) as a2 in i = i+1
******************* STATS **********************
BRUNCH_STAT Assertions 4
BRUNCH_STAT Assumptions 12
BRUNCH_STAT MaxAssumptionsPerAssertion 3
BRUNCH_STAT AvgAssumptionsPerAssertion 3



******* UNJUSTIFIED ASSUMPTION ANALYSIS ********
assert(-i <= -200) with unjustified assumptions:
	assume NotOverflow({i}) as a2 in i = i+1
assert(-x <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
assert(-x+y <= 0) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
assert(i = 100) with unjustified assumptions:
	assume NotOverflow({i}) as a2 in i = i+1
******************* STATS **********************
BRUNCH_STAT Assertions 4
BRUNCH_STAT Assumptions 6
BRUNCH_STAT MaxAssumptionsPerAssertion 2
BRUNCH_STAT AvgAssumptionsPerAssertion 1.5


entry:
  i = 0;
  x = 1;
  y = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assert(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


Analysis using SplitDBM
entry={} ==> {i -> [0, 0], x -> [1, 1], y -> [0, 0]}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
ret={i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> _|_
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {y -> [1, 100], i -> [1, 100], x -> [1, +oo], i-y<=0, y-i<=0, y-x<=0, i-x<=0}
 --- SAFE --------------------
Property : i = 100
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
 -----------------------------
 --- WARNING -----------------
Property : -i <= -200
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
 -----------------------------
integer division by zero checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
2  Number of total unreachable checks
=== End ./test-bin/checker ===
=== Begin ./test-bin/constant_domain ===
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,1);
  i = i+inc;
  goto bb3,bb4;
bb3:
  assume(-i <= -1);
  i = 0;
  goto bb1;
bb4:
  assume(i <= 0);
  goto bb1;
bb1_f:
  goto ret;
ret:
  assert(i = 0);


Invariants using ConstantDomain
Abstract trace: entry (bb1 bb1_t bb2 bb4 bb3)^{1} bb1_f ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  region_init(region_0:region(int));
  i := make_ref(region_0:region(int),4,as_0);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,1);
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *i = *i+inc;
  store_to_ref(region_0:region(int),i:ref,*i:int32);
  goto bb3,bb4;
bb3:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(-*i <= -1);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  goto bb1;
bb4:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(*i <= 0);
  goto bb1;
bb1_f:
  goto ret;
ret:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assert(*i = 0);


Invariants using RegionDomain(ConstantDomain)
Abstract trace: entry (bb1 bb1_t bb2 bb4 bb3)^{1} bb1_f ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/constant_domain ===
=== Begin ./test-bin/crawler-1 ===
void declare main()
exit:
  (x1:int32,x2:int32)= call foo(y1:int32,y2:int32,y3:int32,y4:int32);
  assert(-x1 <= -100);
  assert(-x2 <= -200);


(o1:int32,o2:int32) declare foo(i1:int32,i2:int32,i3:int32,i4:int32)
entry:

Summary table:
	(o1:int32,o2:int32) declare foo(i1:int32,i2:int32,i3:int32,i4:int32) -> Inputs:{i1,i2,i3,i4} Outputs:{o1,o2} ({},{o1 -> {i1; i2}; o2 -> {i3; i4}})

Assertion Crawler Analysis for main
exit={"assert(-x2 <= -200)" -> {y3; y4}; "assert(-x1 <= -100)" -> {y1; y2}}

=== End ./test-bin/crawler-1 ===
=== Begin ./test-bin/crawler-2 ===
void declare main()
entry:
  i = 0;
  x = 1;
  y = 0;
  z = 3;
  w = 3;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  (x:int32,y:int32)= call bar(x:int32,y:int32,z:int32,w:int32);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto exit;
exit:
  assume(x-y <= 0);
  assert(-w <= 0);
  assert(-x+y <= 0);
  assert(-i <= 0);
  goto ret;
ret:


(o1:int32,o2:int32) declare foo(i1:int32,i2:int32,i3:int32,i4:int32)
entry:
  tmp1 = i1+i2;
  tmp2 = i3+i4;
  goto exit;
exit:
  o1 = tmp1;
  o2 = tmp2;


(o1:int32,o2:int32) declare bar(i1:int32,i2:int32,i3:int32,i4:int32)
entry:
  (o1:int32,o2:int32)= call foo(i1:int32,i2:int32,i3:int32,i4:int32);
  goto exit;
exit:
  assert(-o1 <= 0);
  assert(-o2 <= 0);


Assertion Crawler Analysis for main
entry={"assert(-o2 <= 0)" -> {}; "assert(-o1 <= 0)" -> {}; "assert(-i <= 0)" -> {}; "assert(-x+y <= 0)" -> {}; "assert(-w <= 0)" -> {}}
bb1={"assert(-o2 <= 0)" -> {z; w}; "assert(-o1 <= 0)" -> {x; y; z; w}; "assert(-i <= 0)" -> {i}; "assert(-x+y <= 0)" -> {x; y; z; w}; "assert(-w <= 0)" -> {w}}
bb1_f={"assert(-i <= 0)" -> {i}; "assert(-x+y <= 0)" -> {x; y}; "assert(-w <= 0)" -> {w}}
exit={"assert(-i <= 0)" -> {i}; "assert(-x+y <= 0)" -> {x; y}; "assert(-w <= 0)" -> {w}}
ret={}
bb1_t={"assert(-o2 <= 0)" -> {z; w}; "assert(-o1 <= 0)" -> {x; y; z; w}; "assert(-i <= 0)" -> {i}; "assert(-x+y <= 0)" -> {x; y; z; w}; "assert(-w <= 0)" -> {w}}
bb2={"assert(-o2 <= 0)" -> {z; w}; "assert(-o1 <= 0)" -> {x; y; z; w}; "assert(-i <= 0)" -> {i}; "assert(-x+y <= 0)" -> {x; y; z; w}; "assert(-w <= 0)" -> {w}}
Assertion Crawler Analysis for bar
entry={"assert(-o2 <= 0)" -> {i3; i4}; "assert(-o1 <= 0)" -> {i1; i2}}
exit={"assert(-o2 <= 0)" -> {o2}; "assert(-o1 <= 0)" -> {o1}}
Assertion Crawler Analysis for foo
entry={}
exit={}
=== End ./test-bin/crawler-2 ===
=== Begin ./test-bin/dce ===
CFG
x0:
  k = 2147483648;
  o = 4;
  p := make_ref(region_0:region(int),400,as_0);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  (region_0:region(int),q:ref) := gep_ref(region_0:region(int),p:ref + o);
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


After Dead Code Elimination
x0:
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Cloned CFG
x0:
  k = 2147483648;
  o = 4;
  p := make_ref(region_0:region(int),400,as_0);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  (region_0:region(int),q:ref) := gep_ref(region_0:region(int),p:ref + o);
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


CFG
k:int32 declare main()
x0:
  k = 2147483648;
  o = 4;
  p := make_ref(region_0:region(int),400,as_1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  (region_0:region(int),q:ref) := gep_ref(region_0:region(int),p:ref + o);
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k:int32 := load_from_ref(region_0:region(int),q:ref);


After Dead Code Elimination
k:int32 declare main()
x0:
  o = 4;
  p := make_ref(region_0:region(int),400,as_1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  (region_0:region(int),q:ref) := gep_ref(region_0:region(int),p:ref + o);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k:int32 := load_from_ref(region_0:region(int),q:ref);


Cloned CFG
k:int32 declare main()
x0:
  k = 2147483648;
  o = 4;
  p := make_ref(region_0:region(int),400,as_1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  (region_0:region(int),q:ref) := gep_ref(region_0:region(int),p:ref + o);
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k:int32 := load_from_ref(region_0:region(int),q:ref);


=== End ./test-bin/dce ===
=== Begin ./test-bin/disintervals ===
entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using DisjunctiveIntervals
entry={}
bb1={i -> [0, 100]; k -> [0, +oo]}
bb1_f={i -> [0, 100]; k -> [0, +oo]}
ret={i -> [100, 100]; k -> [0, +oo]}
bb1_t={i -> [0, 100]; k -> [0, +oo]}
bb2={i -> [0, 99]; k -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

=== End ./test-bin/disintervals ===
=== Begin ./test-bin/entailment ===
{x -> [5, 10]} does not entail x = 7
{x -> [5, 10]} does not entail x = 11
{x -> [5, 5], y -> [0, 10]} entails x = 5
{x -> [5, 5], y -> [0, 10]} does not entail x = 7
{x -> [5, 5], y -> [0, 10]} entails y != 42
=== End ./test-bin/entailment ===
=== Begin ./test-bin/fixedtvpi ===
Invariants using FixedTVPIDomain(SplitDBM)
entry=top
loop_header={i -> [0, +oo], x -> [0, +oo], y -> [0, +oo], n -> [1, +oo], x.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(8) -> [0, +oo], x.tvpi.ghost_var(4)-i<=0, y.tvpi.ghost_var(8)-i<=0, i-x<=0, x.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(8)-x<=0, i-y<=0, x-y<=0, x.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(8)-y<=0, i-n<=0, x.tvpi.ghost_var(4)-n<=0, y.tvpi.ghost_var(8)-n<=0, i-x.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-x.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(4)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-y.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(8)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(8)<=0}
loop_exit={i -> [0, +oo], x -> [0, +oo], y -> [0, +oo], n -> [1, +oo], x.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(8) -> [0, +oo], x.tvpi.ghost_var(4)-i<=0, y.tvpi.ghost_var(8)-i<=0, i-x<=0, x.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(8)-x<=0, i-y<=0, x-y<=0, x.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(8)-y<=0, i-n<=0, x.tvpi.ghost_var(4)-n<=0, y.tvpi.ghost_var(8)-n<=0, i-x.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-x.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(4)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-y.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(8)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(8)<=0}
exit={i -> [1, +oo], x -> [4, +oo], y -> [8, +oo], n -> [1, +oo], x.tvpi.ghost_var(4) -> [1, +oo], i.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(4) -> [1, +oo], y.tvpi.ghost_var(8) -> [1, +oo], n.tvpi.ghost_var(4) -> [0, +oo], x.tvpi.ghost_var(4)-i<=0, y.tvpi.ghost_var(8)-i<=0, n-i<=0, i-x<=-3, x.tvpi.ghost_var(4)-x<=-3, y.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(8)-x<=-3, n-x<=-3, i-y<=-7, x-y<=0, x.tvpi.ghost_var(4)-y<=-7, y.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(8)-y<=-7, n-y<=-7, i-n<=0, x.tvpi.ghost_var(4)-n<=0, y.tvpi.ghost_var(8)-n<=0, i-x.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-x.tvpi.ghost_var(4)<=0, n-x.tvpi.ghost_var(4)<=0, n.tvpi.ghost_var(4)-i.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(4)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-y.tvpi.ghost_var(4)<=0, n-y.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(8)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(8)<=0, n-y.tvpi.ghost_var(8)<=0, n.tvpi.ghost_var(8)-i.tvpi.ghost_var(8)<=0}
loop_body={i -> [0, +oo], x -> [0, +oo], y -> [0, +oo], n -> [1, +oo], x.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(4) -> [0, +oo], y.tvpi.ghost_var(8) -> [0, +oo], x.tvpi.ghost_var(4)-i<=0, y.tvpi.ghost_var(8)-i<=0, i-x<=0, x.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(4)-x<=0, y.tvpi.ghost_var(8)-x<=0, i-y<=0, x-y<=0, x.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(4)-y<=0, y.tvpi.ghost_var(8)-y<=0, i-n<=0, x.tvpi.ghost_var(4)-n<=0, y.tvpi.ghost_var(8)-n<=0, i-x.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-x.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(4)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(4)<=0, y.tvpi.ghost_var(8)-y.tvpi.ghost_var(4)<=0, i-y.tvpi.ghost_var(8)<=0, x.tvpi.ghost_var(4)-y.tvpi.ghost_var(8)<=0}
Abstract trace: entry (loop_header loop_body)^{4} loop_exit exit

Invariants using FixedTVPIDomain(SplitDBM)
Abstract trace: entry (loop_header loop_body)^{4} loop_exit exit
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Invariants using FixedTVPIDomain(SplitDBM)
entry=top
loop_header={i -> [0, +oo], x -> [0, +oo], n -> [1, +oo], i-x<=0, i-n<=0}
loop_exit={i -> [0, +oo], x -> [0, +oo], n -> [1, +oo], i-x<=0, i-n<=0}
exit={i -> [1, +oo], x -> [2, +oo], n -> [1, +oo], i.tvpi.ghost_var(2) -> [0, +oo], n.tvpi.ghost_var(2) -> [0, +oo], x.tvpi.ghost_var(2) -> [1, +oo], n-i<=0, x.tvpi.ghost_var(3)-i<=0, i-x<=-1, n-x<=-1, x.tvpi.ghost_var(3)-x<=-1, i-n<=0, x.tvpi.ghost_var(3)-n<=0, n.tvpi.ghost_var(2)-i.tvpi.ghost_var(2)<=0, n.tvpi.ghost_var(3)-i.tvpi.ghost_var(3)<=0, n-x.tvpi.ghost_var(2)<=0, i-x.tvpi.ghost_var(2)<=0, x.tvpi.ghost_var(3)-x.tvpi.ghost_var(2)<=0}
loop_body={i -> [0, +oo], x -> [0, +oo], n -> [1, +oo], i-x<=0, i-n<=0}
loop_body_else={x -> [0, +oo], n -> [1, +oo], i -> [1, +oo], i-x<=1, i-n<=0}
loop_body_tail={i -> [1, +oo], x -> [2, +oo], n -> [1, +oo], i-x<=-1, i-n<=0}
loop_body_then={x -> [0, +oo], n -> [1, +oo], i -> [1, +oo], i-x<=1, i-n<=0}
Abstract trace: entry (loop_header loop_body loop_body_else loop_body_then loop_body_tail)^{4} loop_exit exit

Invariants using FixedTVPIDomain(SplitDBM)
Abstract trace: entry (loop_header loop_body loop_body_else loop_body_then loop_body_tail)^{4} loop_exit exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

Check1 passed
Check2 passed
Check3 passed
{y.tvpi.ghost_var(2) -> [0, 3], x -> [0, 3], x.tvpi.ghost_var(2) -> [0, +oo], y -> [0, 6], x-y.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-x<=0}
=== End ./test-bin/fixedtvpi ===
=== Begin ./test-bin/fixedtvpi2 ===
Invariants using FixedTVPIDomain(SplitDBM)
entry=top
header_1={x-y.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-x<=0, z-z2.tvpi.ghost_var(2)<=0, z2.tvpi.ghost_var(2)-z<=0}
exit={x-y.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-x<=0, z-z2.tvpi.ghost_var(2)<=0, x-z2.tvpi.ghost_var(2)<=-3, y.tvpi.ghost_var(2)-z2.tvpi.ghost_var(2)<=-3, z2.tvpi.ghost_var(2)-z<=0, x-z<=-3, y.tvpi.ghost_var(2)-z<=-3, x.tvpi.ghost_var(3)-z.tvpi.ghost_var(3)<=-1}
Abstract trace: entry header_1 exit

Invariants using FixedTVPIDomain(SplitDBM)
Abstract trace: entry header_1 exit
user-defined assertion checker
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Invariants using FixedTVPIDomain(SplitDBM)
entry=top
bb_1={x -> [0, 4], x.tvpi.ghost_var(2) -> [0, 2], x.tvpi.ghost_var(3) -> [0, +oo], y -> [2, 2], y.tvpi.ghost_var(2) -> [1, 1]}
bb_2={x -> [0, 4], x.tvpi.ghost_var(2) -> [0, 2], x.tvpi.ghost_var(3) -> [0, +oo], y -> [2, 2], y.tvpi.ghost_var(2) -> [1, 1], z -> [0, 8], z.tvpi.ghost_var(2) -> [0, 4], z.tvpi.ghost_var(2)-x<=0, x-z.tvpi.ghost_var(2)<=0}
bb_3={x -> [0, 4], x.tvpi.ghost_var(2) -> [0, 2], x.tvpi.ghost_var(3) -> [0, +oo], y -> [2, 2], y.tvpi.ghost_var(2) -> [1, 1], z -> [0, 8], z.tvpi.ghost_var(2) -> [0, 4], m -> [0, +oo], m.tvpi.ghost_var(2) -> [0, +oo], z.tvpi.ghost_var(2)-x<=0, x-z.tvpi.ghost_var(2)<=0, z-m<=0, z.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=0, x-m.tvpi.ghost_var(2)<=0, z.tvpi.ghost_var(3)-m.tvpi.ghost_var(3)<=0}
exit={x -> [0, 4], x.tvpi.ghost_var(2) -> [0, 2], x.tvpi.ghost_var(3) -> [0, +oo], y -> [2, 2], y.tvpi.ghost_var(2) -> [1, 1], z -> [0, 8], z.tvpi.ghost_var(2) -> [0, 4], m -> [0, +oo], m.tvpi.ghost_var(2) -> [0, +oo], j -> [-1, 3], k -> [-2, 6], k.tvpi.ghost_var(2) -> [-1, 3], z.tvpi.ghost_var(2)-x<=0, j-x<=-1, k.tvpi.ghost_var(2)-x<=-1, x-z.tvpi.ghost_var(2)<=0, j-z.tvpi.ghost_var(2)<=-1, k.tvpi.ghost_var(2)-z.tvpi.ghost_var(2)<=-1, z-m<=0, z.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=0, x-m.tvpi.ghost_var(2)<=0, j-m.tvpi.ghost_var(2)<=-1, k.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=-1, z.tvpi.ghost_var(3)-m.tvpi.ghost_var(3)<=0, x-j<=1, z.tvpi.ghost_var(2)-j<=1, k.tvpi.ghost_var(2)-j<=0, j-k.tvpi.ghost_var(2)<=0, x-k.tvpi.ghost_var(2)<=1, z.tvpi.ghost_var(2)-k.tvpi.ghost_var(2)<=1}
Abstract trace: entry bb_1 bb_2 bb_3 exit

Invariants using FixedTVPIDomain(SplitDBM)
Abstract trace: entry bb_1 bb_2 bb_3 exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Invariants using FixedTVPIDomain(SplitDBM)
entry=top
header_1={n-y.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-n<=0}
exit={n-y.tvpi.ghost_var(2)<=0, x.tvpi.ghost_var(2)-y.tvpi.ghost_var(2)<=0, z.tvpi.ghost_var(2)-y.tvpi.ghost_var(2)<=0, m.tvpi.ghost_var(2)-y.tvpi.ghost_var(2)<=0, z'.tvpi.ghost_var(2)-y.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-n<=0, x.tvpi.ghost_var(2)-n<=0, z.tvpi.ghost_var(2)-n<=0, m.tvpi.ghost_var(2)-n<=0, z'.tvpi.ghost_var(2)-n<=0, y-x<=0, z-x<=0, x-y<=0, z-y<=0, y.tvpi.ghost_var(2)-x.tvpi.ghost_var(2)<=0, n-x.tvpi.ghost_var(2)<=0, z.tvpi.ghost_var(2)-x.tvpi.ghost_var(2)<=0, m.tvpi.ghost_var(2)-x.tvpi.ghost_var(2)<=0, z'.tvpi.ghost_var(2)-x.tvpi.ghost_var(2)<=0, x-z<=0, y-z<=0, x.tvpi.ghost_var(2)-z.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-z.tvpi.ghost_var(2)<=0, n-z.tvpi.ghost_var(2)<=0, m.tvpi.ghost_var(2)-z.tvpi.ghost_var(2)<=0, z'.tvpi.ghost_var(2)-z.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=0, n-m.tvpi.ghost_var(2)<=0, x.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=0, z.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=0, z'.tvpi.ghost_var(2)-m.tvpi.ghost_var(2)<=0, m-z'<=0, z'-m<=0, m.tvpi.ghost_var(2)-z'.tvpi.ghost_var(2)<=0, y.tvpi.ghost_var(2)-z'.tvpi.ghost_var(2)<=0, n-z'.tvpi.ghost_var(2)<=0, x.tvpi.ghost_var(2)-z'.tvpi.ghost_var(2)<=0, z.tvpi.ghost_var(2)-z'.tvpi.ghost_var(2)<=0}
Abstract trace: entry header_1 exit

Invariants using FixedTVPIDomain(SplitDBM)
Abstract trace: entry header_1 exit
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/fixedtvpi2 ===
=== Begin ./test-bin/flat_bool_domain1 ===
entry:
  i = 0;
  bf = false;
  bt = true;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  b1 = (i <= 99);
  assume(b1);
  assert(b1);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  b3 = (-i <= -1);
  b4 = b3;
  b4 = b4|bf;
  b4 = b4&bt;
  b4 = b4^bt;
  b4 = b4^bt;
  goto bb1;
bb1_f:
  b2 = (-i <= -100);
  assume(b2);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, +oo]}
bb1_f={i -> [0, +oo]}
ret={i -> [0, +oo]}
bb1_t={i -> [0, +oo]}
bb2={i -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Product(Boolean,SparseDBM)
entry=({}, {})
bb1=({bf -> false; bt -> true}, {i -> [0, 101]})
bb1_f=({bf -> false; bt -> true}, {i -> [0, 101]})
ret=({b2 -> true; bf -> false; bt -> true}, {i -> [100, 101]})
bb1_t=({bf -> false; bt -> true}, {i -> [0, 101]})
bb2=({b1 -> true; bf -> false; bt -> true}, {i -> [0, 99]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

=== End ./test-bin/flat_bool_domain1 ===
=== Begin ./test-bin/flat_bool_domain2 ===
entry:
  i = 0;
  havoc(n);
  b = (n = 10);
  assume(b);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
bb1=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
bb1_f=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
ret=({b -> true}, {i -> [11, 11]; n -> [10, 10]})
bb1_t=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
bb2=({b -> true}, {i -> [0, 10]; n -> [10, 10]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

=== End ./test-bin/flat_bool_domain2 ===
=== Begin ./test-bin/flat_bool_domain3 ===
entry:
  i = 0;
  havoc(n);
  b = (n = 10);
  goto bb0,entry_cnt;
bb0:
  n = 1;
  goto entry_cnt;
entry_cnt:
  assume(b);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
entry_cnt=({}, {i -> [0, 0]})
bb1=({b -> true}, {i -> [0, +oo]})
bb1_f=({b -> true}, {i -> [0, +oo]})
ret=({b -> true}, {i -> [0, +oo]})
bb1_t=({b -> true}, {i -> [0, +oo]})
bb2=({b -> true}, {i -> [0, +oo]; n -> [0, +oo]})
bb0=({}, {i -> [0, 0]})
Abstract trace: entry bb0 entry_cnt (bb1 bb1_t bb2)^{3} bb1_f ret

=== End ./test-bin/flat_bool_domain3 ===
=== Begin ./test-bin/flat_bool_domain4 ===
entry:
  i = 0;
  havoc(n);
  trunc n:64 to n1:32;
  b1 = (n1 = 9);
  assume(b1);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
bb1=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb1_f=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
ret=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb1_t=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb2=({b1 -> true}, {i -> [0, +oo]; n -> [0, +oo]; n1 -> [9, 9]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Product(Boolean,SparseDBM)
entry=({}, {})
bb1=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb1_f=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
ret=({b1 -> true}, {i -> [10, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=-1, n-i<=-1, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb1_t=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb2=({b1 -> true}, {i -> [0, 9], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=0, n-n1<=0, i-n1<=0})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

=== End ./test-bin/flat_bool_domain4 ===
=== Begin ./test-bin/flat_bool_domain5 ===
entry:
  havoc(x);
  b1 = (-x <= -1);
  assume(b1);
  b2 = (-x <= 0);
  b3 = (x <= 10);
  b4 = true;
  b5 = ite(b2,b3,b4);
  assume(b5);
  goto exit;
exit:
  assert(-x <= -1);
  assert(x <= 10);


Invariants using Product(Boolean,Intervals)
Abstract trace: entry exit
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  havoc(x);
  b2 = (-x <= 0);
  b3 = (x <= 10);
  b4 = false;
  b5 = ite(b2,b3,b4);
  assume(b5);
  goto exit;
exit:
  assert(-x <= 0);
  assert(x <= 10);


Invariants using Product(Boolean,Intervals)
Abstract trace: entry exit
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  havoc(x);
  b2 = (-x <= 0);
  b3 = (x <= 10);
  b4 = false;
  b5 = ite(b2,b3,b4);
  assume(not(b5));
  goto exit;
exit:
  assert(x <= 10);


Invariants using Product(Boolean,Intervals)
Abstract trace: entry exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/flat_bool_domain5 ===
=== Begin ./test-bin/flat_bool_domain6 ===
Invariants using Product(Boolean,SparseDBM)
Abstract trace: bb1 bb4 bb2 bb3
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/flat_bool_domain6 ===
=== Begin ./test-bin/flat_bool_domain7 ===
Invariants using Product(Boolean,SparseDBM)
Abstract trace: entry exit
user-defined assertion checker
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/flat_bool_domain7 ===
=== Begin ./test-bin/flat_bool_domain8 ===
Invariants using Product(Boolean,SparseDBM)
Abstract trace: entry bb2 bb1 exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/flat_bool_domain8 ===
=== Begin ./test-bin/gen_abs_dom ===
Join({z -> [10, +oo], y-x<=0},{z -> [5, +oo], y-x<=0})={z -> [5, +oo], y-x<=0}
Meet({z -> [10, +oo], y-x<=0},{z -> [5, +oo], y-x<=0})={z -> [10, +oo], y-x<=0}
Widen({z -> [10, +oo], y-x<=0},{z -> [5, +oo], y-x<=0})={y-x<=0}
w:=x+ 5 in {z -> [10, +oo], y-x<=0}={z -> [10, +oo], y-x<=0, w-x<=5, x-w<=-5, y-w<=-5}
=== End ./test-bin/gen_abs_dom ===
=== Begin ./test-bin/intrinsics ===
x0:
  k = 2147483648;
  i = crab_intrinsic(foo1,i:int32,k:int32);
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  i = crab_intrinsic(foo2,i:int32,k:int32);
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


{}
{}
({}, {})
({}, {})
=== End ./test-bin/intrinsics ===
=== Begin ./test-bin/live-1 ===
entry:
  i = 0;
  x = 1;
  y = 0;
  z = 3;
  w = 3;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd1);
  havoc(nd2);
  x = x+y;
  y = y+1;
  z = z^nd1;
  w = w^nd1;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto exit;
exit:
  assume(x-y <= 0);
  goto ret;
ret:


=== End ./test-bin/live-1 ===
=== Begin ./test-bin/lookahead-widening ===
entry:
  x = 0;
  y = 0;
  goto bb1;
bb1:
  goto bb2,bb3;
bb2:
  assume(x <= 50);
  y = y+1;
  goto bb4;
bb4:
  goto bb5,bb7;
bb5:
  assume(-y <= 0);
  goto bb6;
bb6:
  x = x+1;
  goto bb1;
bb7:
  assume(y <= -1);
  goto exit;
exit:

bb3:
  assume(-x <= -51);
  y = y-1;
  goto bb4;

Invariants using SplitOctagons
entry={}
bb1={-x <= 0; -y <= 0; -x+y <= 0; -x-y <= 0}
bb3={-x <= 0; -y <= 0; -x+y <= 0; -x-y <= 0}
bb4={-x <= 0; -y <= 1; -x+y <= 1; -x-y <= -1}
bb7={-x <= 0; -y <= 1; -x+y <= 1; -x-y <= -1}
exit={y = -1; -x <= -2; -x+y <= 1; -x-y <= -1}
bb5={-x <= 0; -y <= 1; -x+y <= 1; -x-y <= -1}
bb6={-x <= 0; -y <= 0; -x+y <= 1; -x-y <= -1}
bb2={-x <= 0; -y <= 0; -x+y <= 0; -x-y <= 0}
Abstract trace: entry (bb1 bb3 bb2 bb4 bb5 bb6)^{5} bb7 exit

Invariants using LookaheadWideningDomain(SplitOctagons)
entry=top
bb1={-x <= 0; x <= 102; -y <= 0; y <= 51; -x+y <= 0; -x-y <= 0; x+y <= 102; x+y <= 153}
bb3={-x <= 0; x <= 102; -y <= 0; y <= 51; -x+y <= 0; -x-y <= 0; x+y <= 102; x+y <= 153}
bb4={-x <= 0; x <= 102; -y <= 1; y <= 51; -x+y <= 1; -x-y <= -1; x+y <= 101; x+y <= 152}
bb7={-x <= 0; x <= 102; -y <= 1; y <= 51; -x+y <= 1; -x-y <= -1; x+y <= 101; x+y <= 152}
exit={y = -1; -x <= -2; x <= 102; -x+y <= 1; -x-y <= -1; x+y <= 101; x+y <= 152}
bb5={-x <= 0; x <= 102; -y <= 1; y <= 51; -x+y <= 1; -x-y <= -1; x+y <= 101; x+y <= 152}
bb6={-x <= 0; x <= 101; -y <= 0; y <= 51; -x+y <= 1; -x-y <= -1; x+y <= 101; x+y <= 152}
bb2={-x <= 0; x <= 102; -y <= 0; y <= 51; -x+y <= 0; -x-y <= 0; x+y <= 102; x+y <= 153}
Abstract trace: entry (bb1 bb3 bb2 bb4 bb5 bb6)^{7} bb7 exit

=== End ./test-bin/lookahead-widening ===
=== Begin ./test-bin/lower_safe_assertions ===
Analysis using SplitDBM
 --- SAFE --------------------
Property : i = 100
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
 -----------------------------
 --- WARNING -----------------
Property : -i <= -200
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
 -----------------------------
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
2  Number of total unreachable checks
Before replacing safe assertions with assume statements
entry:
  i = 0;
  x = 1;
  y = 0;
  p := make_ref(region_0:region(int),8,as_0);
  (region_0:region(int),l:ref) := gep_ref(region_0:region(int),p:ref);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  store_to_ref(region_0:region(int),p:ref,i:int32);
  q := make_ref(region_0:region(int),8,as_1);
  (region_0:region(int),p_next:ref) := gep_ref(region_0:region(int),p:ref + 4);
  store_to_ref(region_0:region(int),p_next:ref,q:ref);
  (region_0:region(int),p:ref) := gep_ref(region_0:region(int),p_next:ref);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assert(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


After replacing safe assertions with assume statements
entry:
  i = 0;
  x = 1;
  y = 0;
  p := make_ref(region_0:region(int),8,as_0);
  (region_0:region(int),l:ref) := gep_ref(region_0:region(int),p:ref);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  store_to_ref(region_0:region(int),p:ref,i:int32);
  q := make_ref(region_0:region(int),8,as_1);
  (region_0:region(int),p_next:ref) := gep_ref(region_0:region(int),p:ref + 4);
  store_to_ref(region_0:region(int),p_next:ref,q:ref);
  (region_0:region(int),p:ref) := gep_ref(region_0:region(int),p_next:ref);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assume(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


=== End ./test-bin/lower_safe_assertions ===
=== Begin ./test-bin/nested-1 ===
entry:
  i = 0;
  goto l1;
l1:
  i = i+1;
  j = 0;
  goto l2;
l2:
  goto l2_body,l2_exit;
l2_body:
  assume(j <= 9);
  assert(-i <= 0);
  assert(i <= 10);
  j = j+1;
  goto l2;
l2_exit:
  assume(-j <= -10);
  goto l1_reset,l1_dont_reset;
l1_reset:
  assume(-i <= -10);
  i = 0;
  goto l1;
l1_dont_reset:
  assume(i <= 9);
  goto l1;

Invariants using Intervals
Abstract trace: entry (l1 (l2 l2_body)^{12} l2_exit l1_dont_reset l1_reset)^{3}
user-defined assertion checker
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/nested-1 ===
=== Begin ./test-bin/nested-2 ===
entry:
  i = 0;
  goto l1;
l1:
  assume(i <= 3);
  j = 0;
  goto l2;
l2:
  goto l2_body,l2_exit;
l2_body:
  assume(j <= 3);
  assert(i-j <= 3);
  i = i+1;
  j = j+1;
  goto l2;
l2_exit:
  assume(-j <= -4);
  i = i-j+1;
  goto l1;

Invariants using Intervals
Abstract trace: entry (l1 (l2 l2_body)^{13} l2_exit)^{3}
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

Invariants using SplitDBM
Abstract trace: entry (l1 (l2 l2_body)^{12} l2_exit)^{3}
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/nested-2 ===
=== Begin ./test-bin/nested-3 ===
entry:
  i = 0;
  goto l1;
l1:
  assert(-i <= 0);
  j = 0;
  goto l2;
l2:
  goto l2_body,l2_exit;
l2_body:
  assume(j <= 9);
  j = j+1;
  goto l2;
l2_exit:
  assume(-j <= -10);
  i = i-j+11;
  goto l1;

Invariants using Intervals
Abstract trace: entry (l1 (l2 l2_body)^{15} l2_exit)^{4}
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/nested-3 ===
=== Begin ./test-bin/powerset ===
entry:
  x = 0;
  y = 1;
  goto b1;
b1:
  goto b1_tt,b1_ff;
b1_tt:
  assume(-nd1 <= -1);
  x = x+1;
  y = y+2;
  goto b2;
b2:
  goto b2_tt,b2_ff;
b2_tt:
  assume(-nd2 <= -1);
  x = x+2;
  y = y+3;
  goto b3;
b3:
  goto b3_tt,b3_ff;
b3_tt:
  assume(-nd3 <= -1);
  y = y+1;
  goto exit;
exit:
  assert(x-y <= -1);

b3_ff:
  assume(nd3 <= 0);
  goto exit;
b2_ff:
  assume(nd2 <= 0);
  goto b3;
b1_ff:
  assume(nd1 <= 0);
  goto b2;

Invariants using Powerset(ArrayAdaptive(ArraySmashing(Intervals)))
Abstract trace: entry b1 b1_ff b1_tt b2 b2_ff b2_tt b3 b3_ff b3_tt exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Invariants using Intervals
Abstract trace: entry b1 b1_ff b1_tt b2 b2_ff b2_tt b3 b3_ff b3_tt exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/powerset ===
=== Begin ./test-bin/region-1 ===
entry:
  region_init(region_0:region(int));
  region_init(region_1:region(int));
  region_init(region_2:region(int));
  i := make_ref(region_0:region(int),4,as_0);
  x := make_ref(region_1:region(int),4,as_1);
  y := make_ref(region_2:region(int),4,as_2);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  store_to_ref(region_1:region(int),x:ref,1:int32);
  store_to_ref(region_2:region(int),y:ref,0:int32);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(*i <= 99);
  goto bb2;
bb2:
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *x = *x+*y;
  store_to_ref(region_1:region(int),x:ref,*x:int32);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *y = *y+1;
  store_to_ref(region_2:region(int),y:ref,*y:int32);
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *i = *i+1;
  store_to_ref(region_0:region(int),i:ref,*i:int32);
  goto bb1;
bb1_f:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(-*i <= -100);
  goto bb3;
bb3:
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  goto ret;
ret:
  assert(-*x+*y <= 0);


Invariants using RegionDomain(SplitDBM)
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f bb3 ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-1 ===
=== Begin ./test-bin/region-2 ===
entry:
  region_init(region_0:region(int));
  region_init(region_1:region(int));
  region_init(region_2:region(int));
  i := make_ref(region_0:region(int),4,as_0);
  x := make_ref(region_1:region(int),4,as_1);
  y := make_ref(region_2:region(int),4,as_2);
  assume(i > NULL_REF);
  assume(x > NULL_REF);
  assume(y > NULL_REF);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  store_to_ref(region_1:region(int),x:ref,1:int32);
  store_to_ref(region_2:region(int),y:ref,0:int32);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(*i <= 99);
  goto bb2;
bb2:
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *x = *x+*y;
  store_to_ref(region_1:region(int),x:ref,*x:int32);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *y = *y+1;
  store_to_ref(region_2:region(int),y:ref,*y:int32);
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *i = *i+1;
  store_to_ref(region_0:region(int),i:ref,*i:int32);
  goto bb1;
bb1_f:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(-*i <= -100);
  goto ret;
ret:
  assert(x != NULL_REF);
  assert(y != NULL_REF);
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  assert(-*x+*y <= 0);


Invariants using RegionDomain(SplitDBM)
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret
user-defined assertion checker
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-2 ===
=== Begin ./test-bin/region-3 ===
entry:
  region_init(region_field_next:region(ref));
  region_init(region_field_s:region(int));
  region_init(region_field_f:region(int));
  i0 = 0;
  assume(ref0 == NULL_REF);
  goto bb2_loop;
bb2_loop:
  goto bb3,bb4;
bb3:
  assume(i0 <= 9999);
  goto bb5;
bb5:
  ref2 := make_ref(region_field_f:region(int),16,as_0);
  assume(ref2 > NULL_REF);
  (region_field_f:region(int),ref3:ref) := gep_ref(region_field_f:region(int),ref2:ref);
  store_to_ref(region_field_f:region(int),ref3:ref,i0:int32);
  (region_field_s:region(int),ref5:ref) := gep_ref(region_field_f:region(int),ref2:ref + 4);
  store_to_ref(region_field_s:region(int),ref5:ref,30000:int32);
  (region_field_next:region(ref),ref4:ref) := gep_ref(region_field_f:region(int),ref2:ref + 8);
  store_to_ref(region_field_next:region(ref),ref4:ref,ref0:ref);
  i0 = i0+1;
  (region_field_f:region(int),ref0:ref) := gep_ref(region_field_f:region(int),ref2:ref);
  goto bb2_loop;
bb4:
  assume(-i0 <= -10000);
  (region_field_f:region(int),ref1:ref) := gep_ref(region_field_f:region(int),ref0:ref);
  goto bb6_loop;
bb6_loop:
  goto bb7,bb8;
bb7:
  assume(ref1 == NULL_REF);
  goto exit;
exit:

bb8:
  assume(ref1 != NULL_REF);
  goto bb9;
bb9:
  (region_field_f:region(int),ref6:ref) := gep_ref(region_field_f:region(int),ref1:ref);
  x1:int32 := load_from_ref(region_field_f:region(int),ref6:ref);
  assert(x1 <= 9999);
  (region_field_s:region(int),ref7:ref) := gep_ref(region_field_f:region(int),ref1:ref + 4);
  x2:int32 := load_from_ref(region_field_s:region(int),ref7:ref);
  assert(x2 <= 30000);
  (region_field_next:region(ref),ref8:ref) := gep_ref(region_field_f:region(int),ref1:ref + 8);
  ref9:ref := load_from_ref(region_field_next:region(ref),ref8:ref);
  (region_field_f:region(int),ref1:ref) := gep_ref(region_field_f:region(int),ref9:ref);
  goto bb6_loop;

Invariants using RegionDomain(SplitDBM)
Abstract trace: entry (bb2_loop bb3 bb5)^{4} bb4 (bb6_loop bb8 bb9)^{2} bb7 exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-3 ===
=== Begin ./test-bin/region-4 ===
entry:
  region_init(region_field_next:region(ref));
  region_init(region_field_s:region(ref));
  region_init(region_field_deref_s:region(int));
  region_init(region_field_f:region(int));
  i0 = 0;
  assume(ref0 == NULL_REF);
  goto bb2_loop;
bb2_loop:
  goto bb3,bb4;
bb3:
  assume(i0 <= 9999);
  goto bb5;
bb5:
  ref2 := make_ref(region_field_f:region(int),16,as_0);
  assume(ref2 > NULL_REF);
  (region_field_f:region(int),ref3:ref) := gep_ref(region_field_f:region(int),ref2:ref);
  store_to_ref(region_field_f:region(int),ref3:ref,i0:int32);
  (region_field_s:region(ref),ref5:ref) := gep_ref(region_field_f:region(int),ref2:ref + 4);
  ref10 := make_ref(region_field_deref_s:region(int),4,as_1);
  assume(ref10 > NULL_REF);
  store_to_ref(region_field_s:region(ref),ref5:ref,ref10:ref);
  (region_field_next:region(ref),ref4:ref) := gep_ref(region_field_f:region(int),ref2:ref + 8);
  store_to_ref(region_field_next:region(ref),ref4:ref,ref0:ref);
  i0 = i0+1;
  (region_field_f:region(int),ref0:ref) := gep_ref(region_field_f:region(int),ref2:ref);
  goto bb2_loop;
bb4:
  assume(-i0 <= -10000);
  (region_field_f:region(int),ref1:ref) := gep_ref(region_field_f:region(int),ref0:ref);
  goto bb6_loop;
bb6_loop:
  goto bb7,bb8;
bb7:
  assume(ref1 == NULL_REF);
  goto exit;
exit:

bb8:
  assume(ref1 != NULL_REF);
  goto bb9;
bb9:
  (region_field_s:region(ref),ref7:ref) := gep_ref(region_field_f:region(int),ref1:ref + 4);
  ref6:ref := load_from_ref(region_field_s:region(ref),ref7:ref);
  b2 = crab_intrinsic(is_unfreed_or_null,region_field_deref_s:region(int),ref6:ref);
  goto bb9_assert;
bb9_assert:
  assert(b2);
  (region_field_next:region(ref),ref8:ref) := gep_ref(region_field_f:region(int),ref1:ref + 8);
  ref9:ref := load_from_ref(region_field_next:region(ref),ref8:ref);
  (region_field_f:region(int),ref1:ref) := gep_ref(region_field_f:region(int),ref9:ref);
  goto bb6_loop;

Invariants using RegionDomain(Product(Boolean,Intervals))
Abstract trace: entry (bb2_loop bb3 bb5)^{4} bb4 (bb6_loop bb8 bb9 bb9_assert)^{2} bb7 exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  region_init(region_field_next:region(ref));
  region_init(region_field_s:region(ref));
  region_init(region_field_deref_s:region(int));
  region_init(region_field_f:region(int));
  i0 = 0;
  assume(ref0 == NULL_REF);
  goto bb2_loop;
bb2_loop:
  goto bb3,bb4;
bb3:
  assume(i0 <= 9999);
  goto bb5;
bb5:
  ref2 := make_ref(region_field_f:region(int),16,as_0);
  assume(ref2 > NULL_REF);
  (region_field_f:region(int),ref3:ref) := gep_ref(region_field_f:region(int),ref2:ref);
  store_to_ref(region_field_f:region(int),ref3:ref,i0:int32);
  (region_field_s:region(ref),ref5:ref) := gep_ref(region_field_f:region(int),ref2:ref + 4);
  ref10 := make_ref(region_field_deref_s:region(int),4,as_1);
  assume(ref10 > NULL_REF);
  store_to_ref(region_field_s:region(ref),ref5:ref,ref10:ref);
  (region_field_next:region(ref),ref4:ref) := gep_ref(region_field_f:region(int),ref2:ref + 8);
  store_to_ref(region_field_next:region(ref),ref4:ref,ref0:ref);
  i0 = i0+1;
  (region_field_f:region(int),ref0:ref) := gep_ref(region_field_f:region(int),ref2:ref);
  goto bb2_loop;
bb4:
  assume(-i0 <= -10000);
  (region_field_f:region(int),ref1:ref) := gep_ref(region_field_f:region(int),ref0:ref);
  goto bb6_loop;
bb6_loop:
  goto bb7,bb8;
bb7:
  assume(ref1 == NULL_REF);
  goto exit;
exit:

bb8:
  assume(ref1 != NULL_REF);
  goto bb9;
bb9:
  (region_field_s:region(ref),ref7:ref) := gep_ref(region_field_f:region(int),ref1:ref + 4);
  ref6:ref := load_from_ref(region_field_s:region(ref),ref7:ref);
  b2 = crab_intrinsic(is_unfreed_or_null,region_field_deref_s:region(int),ref6:ref);
  remove_ref(region_field_deref_s:region(int),ref6:ref);
  goto bb9_assert;
bb9_assert:
  assert(b2);
  (region_field_next:region(ref),ref8:ref) := gep_ref(region_field_f:region(int),ref1:ref + 8);
  ref9:ref := load_from_ref(region_field_next:region(ref),ref8:ref);
  (region_field_f:region(int),ref1:ref) := gep_ref(region_field_f:region(int),ref9:ref);
  goto bb6_loop;

Invariants using RegionDomain(Product(Boolean,Intervals))
Abstract trace: entry (bb2_loop bb3 bb5)^{4} bb4 (bb6_loop bb8 bb9 bb9_assert)^{2} bb7 exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-4 ===
=== Begin ./test-bin/region-5 ===
entry:
  region_init(region_0:region(int));
  region_init(region_1:region(int));
  region_init(region_2:region(int));
  i := make_ref(region_0:region(int),4,as_0);
  x := make_ref(region_1:region(int),4,as_1);
  y := make_ref(region_2:region(int),4,as_2);
  assume(i != NULL_REF);
  assume(x != NULL_REF);
  assume(y != NULL_REF);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  store_to_ref(region_1:region(int),x:ref,1:int32);
  store_to_ref(region_2:region(int),y:ref,0:int32);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(*i <= 99);
  goto bb2;
bb2:
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *x = *x+*y;
  store_to_ref(region_1:region(int),x:ref,*x:int32);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *y = *y+1;
  store_to_ref(region_2:region(int),y:ref,*y:int32);
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *i = *i+1;
  store_to_ref(region_0:region(int),i:ref,*i:int32);
  goto bb1;
bb1_f:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(-*i <= -100);
  goto bb3;
bb3:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  goto ret;
ret:
  assert(x != NULL_REF);
  assert(y != NULL_REF);
  assert(-*i <= 0);
  assert(-*x <= -1);
  assert(-*y <= 0);
  assert(-*x+*y <= 0);


Invariants using RegionDomain(SignDomain)
Abstract trace: entry (bb1 bb1_t bb2)^{2} bb1_f bb3 ret
user-defined assertion checker
5  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-5 ===
=== Begin ./test-bin/region-6 ===
entry:
  region_init(region_0:region(int));
  region_init(region_1:region(int));
  region_init(region_2:region(int));
  z = 100;
  i := make_ref(region_0:region(int),4,as_0);
  x := make_ref(region_1:region(int),4,as_1);
  y := make_ref(region_2:region(int),4,as_2);
  assume(i != NULL_REF);
  assume(x != NULL_REF);
  assume(y != NULL_REF);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  store_to_ref(region_1:region(int),x:ref,1:int32);
  store_to_ref(region_2:region(int),y:ref,0:int32);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(*i <= 99);
  goto bb2;
bb2:
  z = z+3;
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *x = *x+*y;
  store_to_ref(region_1:region(int),x:ref,*x:int32);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *y = *y+1;
  store_to_ref(region_2:region(int),y:ref,*y:int32);
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *i = *i+1;
  store_to_ref(region_0:region(int),i:ref,*i:int32);
  z = z-3;
  goto bb1;
bb1_f:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(-*i <= -100);
  goto bb3;
bb3:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  goto ret;
ret:
  assert(x != NULL_REF);
  assert(y != NULL_REF);
  assert(-*i <= 0);
  assert(-*x <= -1);
  assert(-*y <= 0);
  assert(-*x+*y <= 0);
  assert(z = 100);


Invariants using RegionDomain(Product(SignDomain,ConstantDomain))
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f bb3 ret
user-defined assertion checker
6  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-6 ===
=== Begin ./test-bin/region-7 ===
entry:
  region_init(rgn_0:region(ref));
  region_init(rgn_1:region(ref));
  region_init(rgn_2:region(ref));
  region_init(rgn_3:region(ref));
  fun1 := make_ref(rgn_0:region(ref),8,as_0);
  fun2 := make_ref(rgn_1:region(ref),8,as_1);
  fun3 := make_ref(rgn_2:region(ref),8,as_2);
  fun_ptr := make_ref(rgn_3:region(ref),8,as_3);
  havoc(orphan_ptr);
  havoc(x);
  goto bb1;
bb1:
  assume(-x <= 0);
  goto bb2,bb3;
bb2:
  assume(-x < 0);
  store_to_ref(rgn_3:region(ref),fun_ptr:ref,fun1:ref);
  goto bb4;
bb4:
  goto bb5,bb6;
bb5:
  assume(x < 0);
  store_to_ref(rgn_3:region(ref),fun_ptr:ref,fun3:ref);
  goto bb6;
bb6:
  res:ref := load_from_ref(rgn_3:region(ref),fun_ptr:ref);
  assert(res != fun3);
  goto ret;
ret:

bb3:
  assume(x <= 0);
  store_to_ref(rgn_3:region(ref),fun_ptr:ref,fun2:ref);
  goto bb4;

Allocation sites for *fun_ptr at the exit: {as_0,as_1}
Allocation sites for orphan_ptr at the exit: unknown
=== End ./test-bin/region-7 ===
=== Begin ./test-bin/region-8 ===
entry:
  region_init(region_0:region(int));
  region_init(region_1:region(int));
  region_init(region_2:region(int));
  i := make_ref(region_0:region(int),4,as_0);
  x := make_ref(region_1:region(int),4,as_1);
  y := make_ref(region_2:region(int),4,as_2);
  crab_intrinsic(add_tag,region_0:region(int),i:ref,1:int32);
  crab_intrinsic(add_tag,region_1:region(int),x:ref,2:int32);
  crab_intrinsic(add_tag,region_2:region(int),y:ref,3:int32);
  store_to_ref(region_0:region(int),i:ref,0:int32);
  store_to_ref(region_1:region(int),x:ref,1:int32);
  store_to_ref(region_2:region(int),y:ref,0:int32);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(*i <= 99);
  goto bb2;
bb2:
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *x = *x+*y;
  store_to_ref(region_1:region(int),x:ref,*x:int32);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  *y = *y+1;
  store_to_ref(region_2:region(int),y:ref,*y:int32);
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  *i = *i+1;
  store_to_ref(region_0:region(int),i:ref,*i:int32);
  goto bb1;
bb1_f:
  *i:int32 := load_from_ref(region_0:region(int),i:ref);
  assume(-*i <= -100);
  goto bb3;
bb3:
  *x:int32 := load_from_ref(region_1:region(int),x:ref);
  *y:int32 := load_from_ref(region_2:region(int),y:ref);
  goto ret;
ret:
  b1 = crab_intrinsic(does_not_have_tag,region_0:region(int),i:ref,2:int32);
  assert(b1);
  b1 = crab_intrinsic(does_not_have_tag,region_0:region(int),i:ref,3:int32);
  assert(b1);
  b1 = crab_intrinsic(does_not_have_tag,region_1:region(int),x:ref,1:int32);
  assert(b1);
  b1 = crab_intrinsic(does_not_have_tag,region_2:region(int),y:ref,1:int32);
  assert(b1);
  b1 = crab_intrinsic(does_not_have_tag,region_1:region(int),x:ref,3:int32);
  assert(b1);


Invariants using RegionDomain(Product(Boolean,Intervals))
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f bb3 ret
user-defined assertion checker
4  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/region-8 ===
=== Begin ./test-bin/soct ===
entry:
  k = 200;
  n = 100;
  x = 0;
  y = k;
  goto loop;
loop:
  goto loop_body_1,ret;
loop_body_1:
  assume(-n+x <= -1);
  goto loop_body_2;
loop_body_2:
  x = x+1;
  goto loop_body_3;
loop_body_3:
  t = 2*x;
  goto loop_body_4;
loop_body_4:
  y = -t+200;
  goto loop;
ret:
  assume(n-x <= 0);
  assert(-k+x+y <= 0);


Invariants using SplitOctagons
Abstract trace: entry (loop loop_body_1 loop_body_2 loop_body_3 loop_body_4)^{4} ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  k = 200;
  n = 100;
  x = 0;
  y = k;
  goto loop;
loop:
  goto loop_body_1,ret;
loop_body_1:
  assume(-n+x <= -1);
  goto loop_body_2;
loop_body_2:
  x = x+1;
  goto loop_body_3;
loop_body_3:
  goto loop_body_4;
loop_body_4:
  y = k-2*x;
  goto loop;
ret:
  assume(n-x <= 0);
  assert(-k+x+y <= 0);


Invariants using SplitOctagons
Abstract trace: entry (loop loop_body_1 loop_body_2 loop_body_3 loop_body_4)^{4} ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  x = 0;
  y = 200;
  goto loop;
loop:
  goto loop_body_1,ret;
loop_body_1:
  assume(x <= 99);
  goto loop_body_2;
loop_body_2:
  x1 = x;
  goto loop_body_3;
loop_body_3:
  x1 = x1+1;
  goto loop_body_4;
loop_body_4:
  y = -2*x1+200;
  x = x1;
  goto loop;
ret:
  assume(-x <= -100);
  assert(x+y <= 200);


Invariants using SplitOctagons
Abstract trace: entry (loop loop_body_1 loop_body_2 loop_body_3 loop_body_4)^{4} ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  k = 200;
  n = 100;
  x = 0;
  y = k;
  goto loop;
loop:
  goto loop_body_1,ret;
loop_body_1:
  assume(-n+x <= -1);
  goto loop_body_2;
loop_body_2:
  x = x+1;
  goto loop_body_3;
loop_body_3:
  t = 2*x;
  goto loop_body_4;
loop_body_4:
  y = k+t;
  goto loop;
ret:
  assume(n-x <= 0);
  assert(k+x-y <= 0);


Invariants using SplitOctagons
Abstract trace: entry (loop loop_body_1 loop_body_2 loop_body_3 loop_body_4)^{4} ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  x = 0;
  y = 200;
  goto loop;
loop:
  goto loop_body,ret;
loop_body:
  assume(x <= 99);
  x1 = x+1;
  y1 = -2*x1+200;
  x = x1;
  y = y1;
  goto loop;
ret:
  assume(-x <= -100);
  assert(x+y <= 200);


Invariants using SplitOctagons
Abstract trace: entry (loop loop_body)^{4} ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/soct ===
=== Begin ./test-bin/td_inter_1 ===
z:int32 declare foo(x:int32)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;


y1:int32 declare bar(a:int32)
entry:
  x1 = a;
  w1 = 5;
  goto exit;
exit:
  y1:int32 = call foo(x1:int32);
  assert(-y1 <= -6);
  assert(y1 <= 17);


t:int32 declare rec1(s:int32)
entry:
  r = s-1;
  goto exit;
exit:
  t:int32 = call rec2(r:int32);


t1:int32 declare rec2(s1:int32)
entry:
  a = 10;
  r1 = s1-1;
  goto exit;
exit:
  t1:int32 = call rec1(r1:int32);
  assert(-a <= -5);


res:int32 declare main()
entry:
  x2 = 3;
  x3 = 4;
  x4 = 5;
  x5 = 6;
  y2:int32 = call bar(x2:int32);
  assert(y2 = 6);
  __:int32 = call rec1(y2:int32);
  goto exit;
exit:
  z2 = y2+2;
  y3:int32 = call bar(x2:int32);
  assert(y3 = 6);
  z3 = y3+z2;
  w2:int32 = call foo(z3:int32);
  assert(w2 = 17);
  y4:int32 = call bar(x3:int32);
  assert(y4 = 7);
  y5:int32 = call bar(x4:int32);
  assert(y5 = 8);
  y6:int32 = call bar(x5:int32);
  assert(y6 = 9);
  res = w2+y4;
  res = res+y5;
  res = res+y6;
  assert(res = 41);


Running top-down inter-procedural analysis with SparseDBM
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
Running top-down inter-procedural analysis with SplitDBM
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
=== End ./test-bin/td_inter_1 ===
=== Begin ./test-bin/td_inter_2 ===
(x_out:int32,y_out:int32) declare loop(x_in:int32,y_in:int32)
entry:
  goto rec_case,base_case;
rec_case:
  assume(x_in <= 100);
  x_next = x_in+1;
  y_next = y_in+1;
  (x_out:int32,y_out:int32)= call loop(x_next:int32,y_next:int32);
  goto exit;
exit:

base_case:
  assume(-x_in <= -101);
  x_out = x_in;
  y_out = y_in;
  goto exit;

(x_res:int32,y_res:int32) declare main()
entry:
  x = 0;
  y = 0;
  (x_res:int32,y_res:int32)= call loop(x:int32,y:int32);
  goto exit;
exit:


(x_out:int32,y_out:int32) declare loop(x_in:int32,y_in:int32)
entry={}
base_case={}
exit={}
rec_case={}
=================================
(x_res:int32,y_res:int32) declare main()
entry={}
exit={x -> [0, 0], y -> [0, 0], y-x<=0, x-y<=0}
=================================
=== End ./test-bin/td_inter_2 ===
=== Begin ./test-bin/td_inter_3 ===
z:int32 declare foo(x:int32,y:int32)
entry:
  goto exit;
exit:
  z = x;


void declare main()
entry:
  x = 5;
  y = 10;
  z = 8;
  goto exit;
exit:
  z:int32 = call foo(x:int32,y:int32);
  assert(x = 5);
  assert(y = 10);
  assert(z = 5);


Running top-down inter-procedural analysis with SplitDBM
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
=== End ./test-bin/td_inter_3 ===
=== Begin ./test-bin/td_inter_4 ===
z:region(int) declare foo(x:int32)
entry:
  region_init(z:region(int));
  ref := make_ref(z:region(int),4,as_0);
  assume(-x+tmp <= 0);
  assume(-tmp < 0);
  goto exit;
exit:
  store_to_ref(z:region(int),ref:ref,tmp:int32);


void declare main()
entry:
  havoc(x);
  assume(-x < 0);
  goto exit;
exit:
  z:region(int) = call foo(x:int32);
  lhs:int32 := load_from_ref(z:region(int),ref:ref);
  assert(-x+lhs <= 0);
  assert(-lhs < 0);


Running top-down inter-procedural analysis with RegionDomain(SplitDBM)
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
=== End ./test-bin/td_inter_4 ===
=== Begin ./test-bin/td_inter_5 ===
b:region(int) declare foo(a:int32)
entry:
  region_init(b:region(int));
  ref := make_ref(b:region(int),4,as_0);
  assume(-a+tmp <= 0);
  assume(-tmp < 0);
  goto exit;
exit:
  store_to_ref(b:region(int),ref:ref,tmp:int32);


void declare main()
entry:
  havoc(x);
  assume(-x < 0);
  goto exit;
exit:
  z:region(int) = call foo(x:int32);
  lhs:int32 := load_from_ref(z:region(int),ref:ref);
  assert(-x+lhs <= 0);
  assert(-lhs < 0);


Running top-down inter-procedural analysis with RegionDomain(SplitDBM)
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
=== End ./test-bin/td_inter_5 ===
=== Begin ./test-bin/td_inter_6 ===
res:int32 declare foo(n:int32)
entry:
  goto base,rec;
base:
  assume(n <= 0);
  res = n;
  goto exit;
exit:

rec:
  assume(-n <= -1);
  n1 = n-1;
  foo_ret:int32 = call foo(n1:int32);
  res = foo_ret+1;
  goto exit;

CallGraph=foo--> foo

Running top-down inter-procedural analysis with SplitDBM
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
res:int32 declare foo(n:int32)
entry={}
rec={}
exit={res-n<=0, n-res<=0}
base={}
=================================
=== End ./test-bin/td_inter_6 ===
=== Begin ./test-bin/td_inter_7 ===
res:int32 declare foo(n:int32)
entry:
  goto base,rec;
base:
  assume(n <= 0);
  res = n;
  goto exit;
exit:

rec:
  assume(-n <= -1);
  n1 = n-1;
  foo_ret:int32 = call foo(n1:int32);
  res = foo_ret+1;
  goto exit;

void declare main()
entry:
  n = 10;
  res:int32 = call foo(n:int32);
  goto exit;
exit:
  assert(res = 10);


CallGraph=foo--> foo
main--> foo

Running top-down inter-procedural analysis with SplitDBM
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
res:int32 declare foo(n:int32)
entry={n -> [-oo, 10]}
rec={n -> [-oo, 10]}
exit={n -> [-oo, 10], res -> [-oo, 10], res-n<=0, n-res<=0}
base={n -> [-oo, 10]}
=================================
void declare main()
entry={}
exit={n -> [10, 10], res -> [10, 10], res-n<=0, n-res<=0}
=================================
=== End ./test-bin/td_inter_7 ===
=== Begin ./test-bin/td_inter_8 ===
res:int32 declare foo(n:int32)
entry:
  goto base,rec;
base:
  assume(n <= 0);
  res = n;
  goto exit;
exit:

rec:
  assume(-n <= -1);
  n1 = n-1;
  foo_ret:int32 = call foo(n1:int32);
  res = foo_ret+1;
  goto exit;

void declare main()
entry:
  n = 10;
  res1:int32 = call foo(n:int32);
  res2:int32 = call foo(n:int32);
  goto exit;
exit:
  assert(res1 = 10);
  assert(res2 = 10);


CallGraph=foo--> foo
main--> foo

Running top-down inter-procedural analysis with SplitDBM
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
res:int32 declare foo(n:int32)
entry={n -> [-oo, 10]}
rec={n -> [-oo, 10]}
exit={n -> [-oo, 10], res -> [-oo, 10], res-n<=0, n-res<=0}
base={n -> [-oo, 10]}
=================================
void declare main()
entry={}
exit={n -> [10, 10], res1 -> [10, 10], res2 -> [10, 10], res1-n<=0, res2-n<=0, n-res1<=0, res2-res1<=0, n-res2<=0, res1-res2<=0}
=================================
=== End ./test-bin/td_inter_8 ===
=== Begin ./test-bin/terms-1 ===
x0:
  k = 50;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
x0={}
bb1={i -> [0, 100]; k -> [50, 50]}
bb1_f={i -> [0, 100]; k -> [50, 50]}
ret={i -> [100, 100]; k -> [50, 50]}
bb1_t={i -> [0, 100]; k -> [50, 50]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
x0={}
bb1={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
bb1_f={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
ret={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [100, 100]}
bb1_t={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

=== End ./test-bin/terms-1 ===
=== Begin ./test-bin/terms-2 ===
p0:
  x = 50;
  havoc(y);
  assume(-y <= 1);
  assume(y <= 1);
  z = x*y;
  goto p_pos,p_neg;
p_pos:
  assume(-y <= 0);
  goto exit;
exit:
  z0 = z;
  y0 = y;
  goto ret;
ret:

p_neg:
  assume(y <= -1);
  z = z*-1;
  goto exit;

Invariants using Intervals
p0={}
p_neg={y -> [-1, 1]; z -> [-50, 50]}
exit={y -> [-1, 1]; z -> [-50, 50]}
ret={y -> [-1, 1]; z -> [-50, 50]; z0 -> [-50, 50]; y0 -> [-1, 1]}
p_pos={y -> [-1, 1]; z -> [-50, 50]}
Abstract trace: p0 p_neg p_pos exit ret

Invariants using Term(Intervals)
p0={}
p_neg={y -> t1[_x1], z -> t2[_x2]}{_x0 -> [50, 50]; _x1 -> [-1, 1]; _x2 -> [-50, 50]}
exit={y -> t0[_y0], z -> t3[_y3]}{_y0 -> [-1, 1]; _y1 -> [-50, 50]; _y2 -> [-1, 1]; _y3 -> [0, 50]}
ret={y -> t0[_y0], z -> t3[_y3], z0 -> t3[_y3], y0 -> t0[_y0]}{_y0 -> [-1, 1]; _y1 -> [-50, 50]; _y2 -> [-1, 1]; _y3 -> [0, 50]}
p_pos={y -> t1[_x1], z -> t2[_x2]}{_x0 -> [50, 50]; _x1 -> [-1, 1]; _x2 -> [-50, 50]}
Abstract trace: p0 p_neg p_pos exit ret

=== End ./test-bin/terms-2 ===
=== Begin ./test-bin/terms-3 ===
entry:
  i = 0;
  x = 5;
  y = 5;
  z = 3;
  w = 3;
  s = 0;
  t = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd1);
  havoc(nd2);
  x = x&nd1;
  y = y&nd1;
  z = z|nd1;
  w = w|nd1;
  s = nd1^nd2;
  t = nd1^nd2;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 100]}
bb1_f={i -> [0, 100]}
ret={i -> [100, 100]}
bb1_t={i -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using SparseDBM
entry={}
bb1={i -> [0, 100]}
bb1_f={i -> [0, 100]}
ret={i -> [100, 100]}
bb1_t={i -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
entry={}
bb1={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
bb1_f={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
ret={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [100, 100]}
bb1_t={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

=== End ./test-bin/terms-3 ===
=== Begin ./test-bin/test1 ===
x0:
  k = 2147483648;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
x0={}
bb1={i -> [0, 101]; k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101]; k -> [2147483648, 2147483648]}
ret={i -> [100, 101]; k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101]; k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

Invariants using SparseDBM
x0={}
bb1={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
bb1_f={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
ret={i -> [100, 101], k -> [2147483648, 2147483648], k-i<=2147483548, i-k<=-2147483547}
bb1_t={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using SplitDBM
x0={}
bb1={i -> [0, 101], k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101], k -> [2147483648, 2147483648]}
ret={i -> [100, 101], k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101], k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Product(Intervals,Congruences)
x0=({}, {})
bb1=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
bb1_f=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
ret=({i -> [100, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
bb1_t=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

Invariants using Term(Intervals)
x0={}
bb1={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [0, 101]}
bb1_f={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [0, 101]}
ret={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [100, 101]}
bb1_t={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [0, 101]}
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

Invariants using DisjunctiveIntervals
x0={}
bb1={i -> [0, 101]; k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101]; k -> [2147483648, 2147483648]}
ret={i -> [100, 101]; k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101]; k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

=== End ./test-bin/test1 ===
=== Begin ./test-bin/test1-real ===
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 5573204538870989/562949953421312);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 6136154492292301/562949953421312]}
bb1_f={i -> [0, 6136154492292301/562949953421312]}
ret={i -> [10, 6136154492292301/562949953421312]}
bb1_t={i -> [0, 6136154492292301/562949953421312]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

=== End ./test-bin/test1-real ===
=== Begin ./test-bin/test2 ===
loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using SparseDBM
loop1_entry={}
loop1_bb1={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
loop1_bb1_f={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
loop2_bb1={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
loop2_bb1_f={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
ret={i -> [10, 10], j -> [10, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=0, k-j<=20, i-k<=-20, j-k<=-20}
loop2_bb1_t={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
loop1_bb1_t={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using SplitDBM
loop1_entry={}
loop1_bb1={i -> [0, 10], k -> [30, 30]}
loop1_bb1_f={i -> [0, 10], k -> [30, 30]}
loop2_bb1={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
loop2_bb1_f={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
ret={i -> [10, 10], j -> [10, 10], k -> [30, 30]}
loop2_bb1_t={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
loop1_bb1_t={i -> [0, 10], k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using Product(Intervals,Congruences)
loop1_entry=({}, {})
loop1_bb1=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
loop1_bb1_f=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
loop2_bb1=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
loop2_bb1_f=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
ret=({i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}, {i -> 10; j -> 10; k -> 30})
loop2_bb1_t=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
loop1_bb1_t=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using Term(Intervals)
loop1_entry={}
loop1_bb1={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
loop1_bb1_f={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
loop2_bb1={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
loop2_bb1_f={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
ret={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [10, 10]}
loop2_bb1_t={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
loop1_bb1_t={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using DisjunctiveIntervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

=== End ./test-bin/test2 ===
=== Begin ./test-bin/test2-real ===
entry:
  x = 0;
  y = 1/2;
  goto bb1;
bb1:
  x = x+y;
  y = y/2;
  goto bb1;

Invariants using Intervals
entry={}
bb1={x -> [0, +oo]; y -> [0, 1/2]}
Abstract trace: entry (bb1)^{3}

=== End ./test-bin/test2-real ===
=== Begin ./test-bin/test3 ===
entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto cont;
cont:
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  goto loop2_body;
loop2_body:
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using SparseDBM
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using SplitDBM
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using Product(Intervals,Congruences)
entry=({}, {})
loop1_head=({i -> [0, 8]}, {})
loop1_f=({i -> [0, 8]}, {})
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t=({i -> [0, 8]}, {})
loop1_body=({i -> [0, 8]}, {})
loop1_body_f=({i -> [1, 9]}, {})
loop1_body_x=({i -> [0, 8]}, {})
loop1_body_t=({i -> [1, 9]}, {})
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using Term(Intervals)
entry={}
loop1_head={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_f={i -> t0[_z0]}{_z0 -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_body={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_body_f={i -> t2[_z2]}{_z0 -> [0, 8]; _z1 -> [1, 1]; _z2 -> [1, 9]}
loop1_body_x={i -> t0[_x0]}{_x0 -> [0, 8]}
loop1_body_t={i -> t2[_z2]}{_z0 -> [0, 8]; _z1 -> [1, 1]; _z2 -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using DisjunctiveIntervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

=== End ./test-bin/test3 ===
=== Begin ./test-bin/test3-real ===
entry:
  x = 1;
  y = 0;
  goto header;
header:
  goto body,exit;
body:
  x = x+y;
  y = y+1;
  goto header;
exit:
  assert(-x+y <= 0);


Invariants using Intervals
entry={}
header={x -> [1, +oo]; y -> [0, +oo]}
exit={x -> [1, +oo]; y -> [0, +oo]}
body={x -> [1, +oo]; y -> [0, +oo]}
Abstract trace: entry (header body)^{3} exit

=== End ./test-bin/test3-real ===
=== Begin ./test-bin/test4 ===
entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop_head={i -> [0, 10]; p -> [0, +oo]}
loop_f={i -> [0, 10]; p -> [0, +oo]}
ret={i -> [10, 10]; p -> [0, +oo]}
loop_t={i -> [0, 10]; p -> [0, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using SparseDBM
entry={}
loop_head={i -> [0, 10], p -> [0, +oo], i-p<=0}
loop_f={i -> [0, 10], p -> [0, +oo], i-p<=0}
ret={i -> [10, 10], p -> [10, +oo], i-p<=0}
loop_t={i -> [0, 10], p -> [0, +oo], i-p<=0}
Abstract trace: entry (loop_head loop_t)^{3} loop_f ret

Invariants using SplitDBM
entry={}
loop_head={i -> [0, 10], p -> [0, +oo], i-p<=0}
loop_f={i -> [0, 10], p -> [0, +oo], i-p<=0}
ret={i -> [10, 10], p -> [10, +oo], i-p<=0}
loop_t={i -> [0, 10], p -> [0, +oo], i-p<=0}
Abstract trace: entry (loop_head loop_t)^{3} loop_f ret

Invariants using Product(Intervals,Congruences)
entry=({}, {})
loop_head=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
loop_f=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
ret=({i -> [10, 10]; p -> [0, +oo]}, {i -> 10; p -> 4Z+0})
loop_t=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using Term(Intervals)
entry={}
loop_head={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
loop_f={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
ret={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [10, 10]; _y1 -> [0, +oo]}
loop_t={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using DisjunctiveIntervals
entry={}
loop_head={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
loop_f={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
ret={i -> [10, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
loop_t={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

=== End ./test-bin/test4 ===
=== Begin ./test-bin/test5 ===
entry:
  i = 0;
  x = 1;
  y = 0;
  z = 3;
  w = 3;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd1);
  havoc(nd2);
  x = x+y;
  y = y+1;
  z = z^nd1;
  w = w^nd1;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto exit;
exit:
  assume(x-y <= 0);
  goto ret;
ret:



Invariants using SparseDBM
entry={}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
exit={x -> [100, +oo], y -> [100, 100], y-x<=0}
ret={x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0}
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

Invariants using SplitDBM
entry={}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
exit={x -> [100, +oo], y -> [100, 100], y-x<=0}
ret={x -> [100, 100], y -> [100, 100], y-x<=0}
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f exit ret

Invariants using Term(DisjunctiveIntervals)
entry={}
bb1={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
bb1_f={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
exit={x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [1, +oo]}
ret={x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [1, 100]}
bb1_t={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
bb2={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 99]; _y1 -> [1, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

Invariants using ReducedProduct(Term(DisjunctiveIntervals),SplitDBM)
entry=({}, {})
bb1=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
bb1_f=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
exit=({x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [100, +oo]}, {x -> [100, +oo], y -> [100, 100], y-x<=0, w-z<=0, z-w<=0})
ret=({x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [100, 100]}, {x -> [100, 100], y -> [100, 100], y-x<=0, w-z<=0, z-w<=0})
bb1_t=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
bb2=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 99]; _y1 -> [1, +oo]}, {i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

=== End ./test-bin/test5 ===
=== Begin ./test-bin/test8 ===
loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  goto loop1_bb2;
loop1_bb2:
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  goto loop2_entry;
loop2_entry:
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  goto loop2_bb2;
loop2_bb2:
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Starting at the entry of CFG:
Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_entry={i -> [10, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb2={i -> [10, 10]; j -> [0, 9]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
loop1_bb2={i -> [0, 9]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Starting at the entry of the second loop:
Invariants using Intervals
loop1_entry=_|_
loop1_bb1=_|_
loop1_bb1_f=_|_
loop2_entry={}
loop2_bb1={j -> [0, 10]}
loop2_bb1_f={j -> [0, 10]}
ret={j -> [10, 10]}
loop2_bb1_t={j -> [0, 10]}
loop2_bb2={j -> [0, 9]}
loop1_bb1_t=_|_
loop1_bb2=_|_
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2) loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Starting at the middle of the second loop:
Invariants using Intervals
loop1_entry=_|_
loop1_bb1=_|_
loop1_bb1_f=_|_
loop2_entry=_|_
loop2_bb1={}
loop2_bb1_f={}
ret={j -> [10, +oo]}
loop2_bb1_t={}
loop2_bb2={}
loop1_bb1_t=_|_
loop1_bb2=_|_
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2) loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{1} loop2_bb1_f ret

=== End ./test-bin/test8 ===
=== Begin ./test-bin/test9 ===
entry:
  i = 0;
  x = 1;
  y = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto bb3;
bb3:
  goto ret;
ret:
  z = x;
  w = y;
  assert(-z+w <= 0);


Invariants using SplitDBM
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f bb3 ret
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

=== End ./test-bin/test9 ===
=== Begin ./test-bin/thresholds ===
Thresholds= {-oo,-999,-89,-10,0,5,10,100,1000,+oo}
next threshold for 3:5
next threshold for 8: 10
next threshold for 100: 1000
next threshold for 500: 1000
next threshold for 10000: +oo
next threshold for -4: 0
prev threshold for -4:-10
prev threshold for -78:-89
prev threshold for -10000:-oo
entry:
  n = 0;
  goto l_1;
l_1:
  goto l_2;
l_2:
  goto l_1,l_3;
l_3:
  goto l_4,l_5;
l_4:
  assume(n <= 59);
  n = n+1;
  goto l_6;
l_6:
  goto l_1;
l_5:
  assume(-n <= -60);
  n = 0;
  goto l_6;

Invariants using Intervals
entry={}
l_1={n -> [0, +oo]}
l_2={n -> [0, +oo]}
l_3={n -> [0, +oo]}
l_5={n -> [0, +oo]}
l_6={n -> [0, 60]}
l_4={n -> [0, +oo]}
Abstract trace: entry (l_1 l_2 l_3 l_5 l_4 l_6)^{3}

Invariants using Intervals
entry={}
l_1={n -> [0, 60]}
l_2={n -> [0, 60]}
l_3={n -> [0, 60]}
l_5={n -> [0, 60]}
l_6={n -> [0, 60]}
l_4={n -> [0, 60]}
Abstract trace: entry (l_1 l_2 l_3 l_5 l_4 l_6)^{3}

entry:
  n = 0;
  goto loop1_header;
loop1_header:
  goto loop1_bb0,loop1_bb1,cont;
loop1_bb0:
  havoc(x);
  assume(-x <= 0);
  goto loop1_header;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(n <= 59);
  goto loop1_bb2;
loop1_bb2:
  n = n+1;
  goto loop1_bb4;
loop1_bb4:
  goto loop1_header;
loop1_bb1_f:
  assume(-n <= -60);
  goto loop1_bb3;
loop1_bb3:
  n = 0;
  goto loop1_bb4;
cont:
  n = 0;
  goto loop2_header;
loop2_header:
  goto loop2_bb0,loop2_bb1,ret;
loop2_bb0:
  havoc(x);
  assume(-x <= -10);
  goto loop2_header;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(n <= 160);
  goto loop2_bb2;
loop2_bb2:
  n = n+2;
  goto loop2_bb4;
loop2_bb4:
  goto loop2_header;
loop2_bb1_f:
  assume(-n <= -161);
  goto loop2_bb3;
loop2_bb3:
  n = 0;
  goto loop2_bb4;
ret:


Thresholds per loop 
loop2_header={-oo,0,9,161,+oo}
loop1_header={-oo,-1,60,+oo}

=== End ./test-bin/thresholds ===
=== Begin ./test-bin/unittests-array-adaptive ===
Unit tests for array adaptive domain

({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) | ({}, {A[4...7] -> [10, 10]; C[8...11] -> [32, 32]})=({}, {A[4...7] -> [5, 10]})
({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) |= ({}, {A[4...7] -> [10, 10]; C[8...11] -> [32, 32]})=({}, {A[4...7] -> [5, 10]})
({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) & ({}, {A[4...7] -> [10, 10]; C[8...11] -> [32, 32]})=_|_
({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) & ({}, {A[4...7] -> [5, 5]; C[8...11] -> [32, 32]})=({}, {B[0...3] -> [66, 66]; C[8...11] -> [32, 32]; A[4...7] -> [5, 5]})
=== End ./test-bin/unittests-array-adaptive ===
=== Begin ./test-bin/unittests-backward ===
Test using ArrayAdaptive(ArraySmashing(Intervals))
EXPECTED: {M[4..7] >= 1} 
RESULT: {M[4...7] -> [1, +oo]}
============================
Test using ArrayAdaptive(ArraySmashing(Intervals))
EXPECTED: {z >= 2, ...}
RESULT: {x -> [2, +oo]; y -> [1, +oo]; z -> [2, +oo]}
============================
Test using ArrayAdaptive(ArraySmashing(Intervals))
EXPECTED: _|_
RESULT: _|_
============================
Test using ArrayAdaptive(ArraySmashing(Intervals))
EXPECTED: {y >= 2, ...}
RESULT: {x -> [2, +oo]; y -> [2, +oo]}
=== End ./test-bin/unittests-backward ===
=== Begin ./test-bin/unittests-linear-constraints ===
Before normalize constraints {x <= 8; -y <= -5; y <= 6; -x <= -8; -v <= -9888; z = 10; w <= 0; v <= 9888}
After normalize constraints {x = 8; v = 9888; -y <= -5; y <= 6; z = 10; w <= 0}
After adding x <= 8: {x <= 8}
After adding y >= 5: {x <= 8,-y <= -5}
After adding y <= 6: {x <= 8,y <= 6,-y <= -5}
After adding x >= 8: {x <= 8,y <= 6,-y <= -5,-x <= -8}
After adding x <= 8: {x <= 8,y <= 6,-y <= -5,-x <= -8}
--------------
Checking if {x <= 8,y <= 6,-y <= -5,-x <= -8} <= {x <= 8,-y <= -5}=0
Checking if {x <= 8,-y <= -5} <= {x <= 8,y <= 6,-y <= -5,-x <= -8}=1
--------------
{x <= 8,y <= 6,-y <= -5,-x <= -8} & {x <= 8,-y <= -5}={x <= 8,-y <= -5}
--------------
{x <= 8,y <= 6,-y <= -5,-x <= -8} | {x <= 8,-z <= -4,-y <= -5}={x <= 8,y <= 6,-z <= -4,-y <= -5,-x <= -8}
--------------
{x <= 8,y <= 6,-y <= -5,-x <= -8} | {...}={...}
--------------
{-x <= 0; false}
is false=1
--------------
=== End ./test-bin/unittests-linear-constraints ===
=== Begin ./test-bin/unittests-num-packing ===
EXPECTED={({x,y},{x=y})} ACTUAL={Pack({x,y},{x-y<=0, y-x<=0})
EXPECTED=_|_ ACTUAL=_|_
EXPECTED=top ACTUAL=top
EXPECTED={({x},{x->[5,10]}),({y},{y->10}),({z},{z->0})} ACTUAL={Pack({x},{x -> [5, 10]}),Pack({y},{y -> [10, 10]}),Pack({z},{z -> [0, 0]})
EXPECTED={({x,y},{x->10, y->10}), ({z},{z->0})} ACTUAL={Pack({x,y},{y -> [10, 10], x -> [10, 10]}),Pack({z},{z -> [0, 0]})
EXPECTED={({x},{x->10}), ({z},{z->0})} ACTUAL={Pack({x},{x -> [10, 10]}),Pack({z},{z -> [0, 0]})
EXPECTED={({w},{w->5}),({z},{z->10})} ACTUAL={Pack({w},{w -> [5, 5]}),Pack({z},{z -> [10, 10]})
EXPECTED={({w},{w->5}),({z},{z->10}), ({x,y},{x=y})} ACTUAL={Pack({x,y},{x-y<=0, y-x<=0}),Pack({w},{w -> [5, 5]}),Pack({z},{z -> [10, 10]})
=== End ./test-bin/unittests-num-packing ===
=== Begin ./test-bin/unittests-regions ===
Join of
	{x -> [5, +oo]; y -> [10, +oo]}
and
	{x -> [5, +oo]; region_0 -> [34, 34]} =
	{x -> [5, +oo]}
Join of
	{x -> [5, +oo]; y -> [10, +oo]}
and
	{x -> [5, +oo]; region_0 -> [34, 34]} =
	{x -> [5, +oo]}
Unit test 1 for select_ref
entry:
  region_init(rgn1:region(int));
  region_init(rgn2:region(int));
  region_init(rgn3:region(int));
  assume(ref2 > NULL_REF);
  assume(ref3 > NULL_REF);
  havoc(cond);
  (ref1,rgn1) = ite(cond,(ref2,rgn2),(ref3,rgn3));
  goto exit;
exit:
  assert(ref1 != NULL_REF);

Invariants using RegionDomain(Intervals)
Abstract trace: entry exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Unit test 2 for select_ref
entry:
  region_init(rgn1:region(int));
  region_init(rgn2:region(int));
  region_init(rgn3:region(int));
  assume(ref2 > NULL_REF);
  (ref1,rgn1) = ite(cond,(ref2,rgn2),(ref3,rgn3));
  goto exit;
exit:
  assert(ref1 != NULL_REF);

Invariants using RegionDomain(Product(Boolean,Intervals))
Abstract trace: entry exit
user-defined assertion checker
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

Unit test 3 for select_ref
entry:
  region_init(rgn1:region(int));
  region_init(rgn2:region(int));
  region_init(rgn3:region(int));
  assume(ref2 == NULL_REF);
  havoc(cond);
  (ref1,rgn1) = ite(cond,NULL_REF,(ref2,rgn2));
  goto exit;
exit:
  assert(ref1 == NULL_REF);

Invariants using RegionDomain(Intervals)
Abstract trace: entry exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Unit test 4 for select_ref
entry:
  region_init(rgn1:region(int));
  region_init(rgn2:region(int));
  region_init(rgn3:region(int));
  assume(ref2 > NULL_REF);
  cond = true;
  (ref1,rgn1) = ite(cond,(ref2,rgn2),(ref3,rgn3));
  goto exit;
exit:
  assert(ref1 != NULL_REF);

Invariants using RegionDomain(Product(Boolean,Intervals))
Abstract trace: entry exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Unit test 5 for select_ref
entry:
  assume(ref3 > NULL_REF);
  cond = false;
  (ref1,rgn1) = ite(cond,(ref2,rgn2),(ref3,rgn3));
  goto exit;
exit:
  assert(ref1 != NULL_REF);

Invariants using RegionDomain(Product(Boolean,Intervals))
Abstract trace: entry exit
user-defined assertion checker
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Unit test 6 for rename
({}, {x0 -> [5, 5]; x1 -> [10, 10]})
After renaming {x0,x1} with {y0,y1}=({}, {y0 -> [5, 5]; y1 -> [10, 10]})
({}, {rgn1 -> [20, 20]; rgn2 -> [30, 30]})
After renaming {rgn1,rgn2} with {rgn3,rgn4}=({}, {rgn3 -> [20, 20]; rgn4 -> [30, 30]})
=== End ./test-bin/unittests-regions ===
=== Begin ./test-bin/unittests-rename ===
 ===== Intervals ====
Before renaming {x -> [-oo, 0]; y -> [5, 5]}
After rename x with w and y with z={z -> [5, 5]; w -> [-oo, 0]}
After rename x with w={y -> [5, 5]; w -> [-oo, 0]}
 ===== SplitDBM ====
Before renaming {x -> [-oo, 0], y -> [5, 5]}
After rename x with w and y with z={w -> [-oo, 0], z -> [5, 5]}
After rename x with w={w -> [-oo, 0], y -> [5, 5]}
 ===== SparseDBM ====
Before renaming {x -> [-oo, 0], y -> [5, 5], x-y<=-5}
After rename x with w and y with z={w -> [-oo, 0], z -> [5, 5], w-z<=-5}
After rename x with w={w -> [-oo, 0], y -> [5, 5], w-y<=-5}
 ===== Term(Intervals) ====
Before renaming {x -> t0[_x0], y -> t1[_x1]}{_x0 -> [-oo, 0]; _x1 -> [5, 5]}
After rename x with w and y with z={z -> t1[_x1], w -> t0[_x0]}{_x0 -> [-oo, 0]; _x1 -> [5, 5]}
After rename x with w={y -> t1[_x1], w -> t0[_x0]}{_x0 -> [-oo, 0]; _x1 -> [5, 5]}
=== End ./test-bin/unittests-rename ===
=== Begin ./test-bin/unittests-uf ===
=== Join === 
{x -> *(8,5), y -> 8} | {x -> *($VAR_0,5), y -> $VAR_0} = {x -> *($VAR_0,5), y -> $VAR_0}
{x -> 1} | {x -> +(1,1)} = {x -> $VAR_0}
=== Equalities/Disequalities === 
Extracting equalities from {y -> $VAR_0, x1 -> *($VAR_0,5), x2 -> *($VAR_0,5), x3 -> *($VAR_0,8)}={x1-x2 = 0}
After adding x1-x2 = 0 --> {y -> $VAR_0, x1 -> *($VAR_0,5), x2 -> *($VAR_0,5), x3 -> *($VAR_0,8)}
After adding x1-x2 != 0 --> _|_
=== Project === 
Before project {x -> 5, y -> 5, z -> 9}
After project {x -> 5, y -> 5}
==== Meet ====
Meet
  {x -> 5, y -> +(5,3), w -> 5, z -> 3} 
  {x -> +(8,2), y -> 8, w -> 8, z -> 2}
Result={x -> +($VAR_0,$VAR_1), y -> +($VAR_0,$VAR_1), w -> +($VAR_0,$VAR_1), z -> $VAR_1}
Meet
  {x -> 5, y -> +(5,10), w -> 5, z -> 10} 
  {x -> +(7,10), y -> 7, w -> 7, z -> 10}
Result={x -> +($VAR_0,$VAR_1), y -> +($VAR_0,$VAR_1), w -> +($VAR_0,$VAR_1), z -> $VAR_1}
==== Boolean operations ====
Extracting equalities from {b1 -> $VAR_1, b2 -> band($VAR_1,$VAR_0), b3 -> band($VAR_1,$VAR_0), b4 -> $VAR_0, b5 -> $VAR_0, b6 -> bor($VAR_1,$VAR_0), b7 -> bxor($VAR_1,$VAR_0)}={b2-b3 = 0; b4-b5 = 0}
=== End ./test-bin/unittests-uf ===
=== Begin ./test-bin/unittests-union-find ===
Dom1={{v1}=>{x -> [5, 5]; y -> [10, 10]},{v2}=>{x -> [5, 5]; y -> [10, 10]},{v3}=>{x -> [5, 5]; y -> [10, 10]},{v4}=>{x -> [5, 5]; y -> [10, 10]}}
After join v1 and v2={{v1,v2}=>{x -> [5, 5]; y -> [10, 10]},{v3}=>{x -> [5, 5]; y -> [10, 10]},{v4}=>{x -> [5, 5]; y -> [10, 10]}}
Dom2={{v1}=>{x -> [10, 10]; y -> [20, 20]},{v2}=>{x -> [10, 10]; y -> [20, 20]},{v3}=>{x -> [10, 10]; y -> [20, 20]},{v4}=>{x -> [10, 10]; y -> [20, 20]}}
After join v3 and v4={{v1}=>{x -> [10, 10]; y -> [20, 20]},{v2}=>{x -> [10, 10]; y -> [20, 20]},{v3,v4}=>{x -> [10, 10]; y -> [20, 20]}}
Dom1 <= Dom2 = 0
Dom2 <= Dom1 = 0
Dom3 = Dom1 | Dom2 = {{v1,v2}=>{x -> [5, 10]; y -> [10, 20]},{v3,v4}=>{x -> [5, 10]; y -> [10, 20]}}
Dom1 <= Dom3 = 1
Dom2 <= Dom3 = 1
Dom4 = Dom1 & Dom2 = _|_
After forgetting v2:{{v1}=>{x -> [5, 10]; y -> [10, 20]},{v3,v4}=>{x -> [5, 10]; y -> [10, 20]}}
After renaming {v1,v2,v3,v4} with {v5,v6,v7,v8} in Dom3:{{v5,v6}=>{x -> [5, 10]; y -> [10, 20]},{v7,v8}=>{x -> [5, 10]; y -> [10, 20]}}
After projecting on v1 and v3 in Dom3:{{v1}=>{x -> [5, 10]; y -> [10, 20]},{v3}=>{x -> [5, 10]; y -> [10, 20]}}
Dom1={{v1,v2}=>false,{v3,v4}=>false}
Dom2={{v1}=>false,{v2,v3}=>false,{v4}=>false}
Dom1 & Dom2 = {{v1,v2,v3,v4}=>false}
Dom1={{v1,v2}=>false,{v3,v4}=>false}
Dom2={{v5}=>false,{v6,v7}=>false,{v8}=>false}
Dom1 & Dom2 = {{v1,v2}=>false,{v3,v4}=>false,{v5}=>false,{v6,v7}=>false,{v8}=>false}
Dom1={{v1,v2}=>false,{v3,v4}=>false}
Dom2={{v3}=>false,{v4}=>false,{v7,v8}=>false}
Dom1 & Dom2 = {{v1,v2}=>false,{v3,v4}=>false,{v7,v8}=>false}
=== End ./test-bin/unittests-union-find ===
=== Begin ./test-bin/unittests-value-partitioning ===
===== Initially ======
top
Start partitioning on x
After x:=5;y:=10 ({x=[5, 5] => {x -> [5, 5], y -> [10, 10]}})
After x:=10;y:=20 ({x=[10, 10] => {x -> [10, 10], y -> [20, 20]}})
After join ({x=[5, 5] => {x -> [5, 5], y -> [10, 10]}, x=[10, 10] => {x -> [10, 10], y -> [20, 20]}})
Start partitioning on z
After z:=5;w:=10 ({x=[5, 5] => {x -> [5, 5], y -> [10, 10], z -> [5, 5], w -> [10, 10]}, x=[10, 10] => {x -> [10, 10], y -> [20, 20], z -> [5, 5], w -> [10, 10]}}, {z=[5, 5] => {x -> [5, 10], y -> [10, 20], z -> [5, 5], w -> [10, 10], y-x<=10, x-y<=-5}})
After z:=10;w:=20 ({x=[5, 5] => {x -> [5, 5], y -> [10, 10], z -> [10, 10], w -> [20, 20]}, x=[10, 10] => {x -> [10, 10], y -> [20, 20], z -> [10, 10], w -> [20, 20]}}, {z=[10, 10] => {x -> [5, 10], y -> [10, 20], z -> [10, 10], w -> [20, 20], y-x<=10, x-y<=-5}})
After join ({x=[5, 5] => {x -> [5, 5], y -> [10, 10], w -> [10, 20], z -> [5, 10], z-w<=-5, w-z<=10}, x=[10, 10] => {x -> [10, 10], y -> [20, 20], w -> [10, 20], z -> [5, 10], z-w<=-5, w-z<=10}}, {z=[5, 5] => {x -> [5, 10], y -> [10, 20], z -> [5, 5], w -> [10, 10], y-x<=10, x-y<=-5}, z=[10, 10] => {x -> [5, 10], y -> [10, 20], z -> [10, 10], w -> [20, 20], y-x<=10, x-y<=-5}})
End partitioning on x
({z=[5, 5] => {x -> [5, 10], y -> [10, 20], z -> [5, 5], w -> [10, 10], y-x<=10, x-y<=-5}, z=[10, 10] => {x -> [5, 10], y -> [10, 20], z -> [10, 10], w -> [20, 20], y-x<=10, x-y<=-5}})
End partitioning on z
{x -> [5, 10], y -> [10, 20], w -> [10, 20], z -> [5, 10], y-x<=10, x-y<=-5, z-w<=-5, w-z<=10}
===== Infer bottom ======
top
Start partitioning on x
After x:=5;y:=10 ({x=[5, 5] => {x -> [5, 5], y -> [10, 10]}})
After x:=10;y:=20 ({x=[10, 10] => {x -> [10, 10], y -> [20, 20]}})
After join ({x=[5, 5] => {x -> [5, 5], y -> [10, 10]}, x=[10, 10] => {x -> [10, 10], y -> [20, 20]}})
Start partitioning on z
After z:=5;w:=10 ({x=[5, 5] => {x -> [5, 5], y -> [10, 10], z -> [5, 5], w -> [10, 10]}, x=[10, 10] => {x -> [10, 10], y -> [20, 20], z -> [5, 5], w -> [10, 10]}}, {z=[5, 5] => {x -> [5, 10], y -> [10, 20], z -> [5, 5], w -> [10, 10], y-x<=10, x-y<=-5}})
After z:=10;w:=20 ({x=[5, 5] => {x -> [5, 5], y -> [10, 10], z -> [10, 10], w -> [20, 20]}, x=[10, 10] => {x -> [10, 10], y -> [20, 20], z -> [10, 10], w -> [20, 20]}}, {z=[10, 10] => {x -> [5, 10], y -> [10, 20], z -> [10, 10], w -> [20, 20], y-x<=10, x-y<=-5}})
After join ({x=[5, 5] => {x -> [5, 5], y -> [10, 10], w -> [10, 20], z -> [5, 10], z-w<=-5, w-z<=10}, x=[10, 10] => {x -> [10, 10], y -> [20, 20], w -> [10, 20], z -> [5, 10], z-w<=-5, w-z<=10}}, {z=[5, 5] => {x -> [5, 10], y -> [10, 20], z -> [5, 5], w -> [10, 10], y-x<=10, x-y<=-5}, z=[10, 10] => {x -> [5, 10], y -> [10, 20], z -> [10, 10], w -> [20, 20], y-x<=10, x-y<=-5}})
_|_
===== Join (EXPECTED Top) ======
Join
	({v1=[5, 5] => {v1 -> [5, 5], v2 -> [10, 10]}, v1=[10, 10] => {v1 -> [10, 10], v2 -> [20, 20]}}, {v3=[-oo, +oo] => {v1 -> [5, 10], v2 -> [10, 20], v2-v1<=10, v1-v2<=-5}})
	({v1=[-oo, +oo] => {v3 -> [50, 52], v4 -> [60, 62], v4-v3<=10, v3-v4<=-10}}, {v3=[50, 50] => {v3 -> [50, 50], v4 -> [60, 60]}, v3=[52, 52] => {v3 -> [52, 52], v4 -> [62, 62]}})
RES:top
===== Meet (EXPECTED non-bot/non-top ======
Meet
	({v1=[5, 5] => {v1 -> [5, 5], v2 -> [10, 10]}, v1=[10, 10] => {v1 -> [10, 10], v2 -> [20, 20]}}, {v3=[-oo, +oo] => {v1 -> [5, 10], v2 -> [10, 20], v2-v1<=10, v1-v2<=-5}})
	({v1=[-oo, +oo] => {v3 -> [50, 52], v4 -> [60, 62], v4-v3<=10, v3-v4<=-10}}, {v3=[50, 50] => {v3 -> [50, 50], v4 -> [60, 60]}, v3=[52, 52] => {v3 -> [52, 52], v4 -> [62, 62]}})
RES:({v1=[5, 10] => {v1 -> [5, 10], v2 -> [10, 20], v3 -> [50, 52], v4 -> [60, 62], v2-v1<=10, v1-v2<=-5, v4-v3<=10, v3-v4<=-10}}, {v3=[50, 52] => {v1 -> [5, 10], v2 -> [10, 20], v3 -> [50, 52], v4 -> [60, 62], v2-v1<=10, v1-v2<=-5, v4-v3<=10, v3-v4<=-10}})
===== Join EXPECTED non-top ======
Join
	({v1=[5, 5] => {v1 -> [5, 5], v2 -> [10, 10]}, v1=[10, 10] => {v1 -> [10, 10], v2 -> [20, 20]}})
	({v1=[50, 50] => {v1 -> [50, 50], v2 -> [60, 60]}, v1=[52, 52] => {v1 -> [52, 52], v2 -> [62, 62]}})
RES:({v1=[5, 5] => {v1 -> [5, 5], v2 -> [10, 10]}, v1=[10, 10] => {v1 -> [10, 10], v2 -> [20, 20]}, v1=[50, 50] => {v1 -> [50, 50], v2 -> [60, 60]}, v1=[52, 52] => {v1 -> [52, 52], v2 -> [62, 62]}})
===== Meet EXPECTED bot ======
Meet
	({v1=[5, 5] => {v1 -> [5, 5], v2 -> [10, 10]}, v1=[10, 10] => {v1 -> [10, 10], v2 -> [20, 20]}})
	({v1=[50, 50] => {v1 -> [50, 50], v2 -> [60, 60]}, v1=[52, 52] => {v1 -> [52, 52], v2 -> [62, 62]}})
RES:_|_
=== End ./test-bin/unittests-value-partitioning ===
=== Begin ./test-bin/unittests-zones ===
{A -> [0, +oo], x -> [0, 0], x-A<=0}
Before x != 0: {x -> [0, 10], y -> [0, 10], z -> [0, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, x-z<=0, y-z<=0}
After x != 0: {x -> [1, 10], y -> [1, 10], z -> [1, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, x-z<=0, y-z<=0}
Before x != 10: {x -> [0, 10], y -> [0, 10], z -> [0, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, u-v<=0, v-u<=0, x-z<=0, y-z<=0}
After x != 10: {x -> [0, 9], y -> [0, 9], z -> [0, 9], y-x<=0, z-x<=0, x-y<=0, z-y<=0, u-v<=0, v-u<=0, x-z<=0, y-z<=0}
DBM1={x -> [1, 1], y -> [1, 1], y-x<=0, x-y<=0}
DBM2={y -> [1, +oo]}
DBM1 & DBM2={y -> [1, 1], x -> [1, 1], x-y<=0, y-x<=0}
Before normalize constraints {x <= 8; -y <= -5; y <= 6; -x <= -8; -v <= -9888; z = 10; w <= 0; v <= 9888}
After normalize constraints {x = 8; v = 9888; -y <= -5; y <= 6; z = 10; w <= 0}
Adding constraint 1 x = -9223372036854775808
Dom1={}
Csts1={}
Adding constraint 2 x = -9223372036854775807
Dom2={x -> [-9223372036854775807, -9223372036854775807]}
Csts2={-x <= 9223372036854775807; x <= -9223372036854775807}
{y -> [0, +oo], x -> [0, 9223372036854775296]}
Join of {x -> [5, 5], y -> [5, 5]} and {x -> [10, 10], y -> [10, 10]}={x -> [5, 10], y -> [5, 10], y-x<=0, x-y<=0}
Meet of {x -> [5, 5], y -> [5, 5]} and {x -> [10, 10], y -> [10, 10]}=_|_
Join of {x -> [5, 5], y -> [5, 5]} and {x -> [10, 10], y -> [10, 10]}={x -> [5, 10], y -> [5, 10], y-x<=0, x-y<=0}
Meet of {x -> [5, 5], y -> [5, 5]} and {x -> [10, 10], y -> [10, 10]}=_|_
Join of {x -> [5, 5], y -> [5, 5]} and {x -> [10, 10], y -> [10, 10]}={x -> [5, 10], y -> [5, 10], y-x<=0, x-y<=0}
Meet of {x -> [5, 5], y -> [5, 5]} and {x -> [10, 10], y -> [10, 10]}=_|_
=== End ./test-bin/unittests-zones ===
=== Begin ./test-bin/wrapint ===
Bitwidth=3
5+7=4
5-7=6
5*7=3
1450 converted to 2
Bitwidth=8
5+7=12
5-7=254
5*7=35
224/2=240
5%7=5
Bitwidth=64
5+7=12
5-7=18446744073709551614
5*7=35
n1=0111
n2=1100
sext of n1 to 8 bits 00000111
sext of n2 to 8 bits 11111100
zext of n1 to 8 bits 00000111
zext of n2 to 8 bits 00001100
n=10101100
zext of n to 16 bits 0000000010101100
sext of n to 16 bits 1111111110101100
n1=00000000000000000000000000000111
n2=11111111111100001011110111000001
sext of n1 to 63 bits 000000000000000000000000000000000000000000000000000000000000111
sext of n2 to 63 bits 111111111111111111111111111111111111111111100001011110111000001
zext of n1 to 63 bits 000000000000000000000000000000000000000000000000000000000000111
zext of n2 to 63 bits 000000000000000000000000000000011111111111100001011110111000001
n1=00000000000000000000000000000111
n2=11111111111100001011110111000001
sext of n1 to 64 bits 0000000000000000000000000000000000000000000000000000000000000111
sext of n2 to 64 bits 1111111111111111111111111111111111111111111100001011110111000001
zext of n1 to 64 bits 0000000000000000000000000000000000000000000000000000000000000111
zext of n2 to 64 bits 0000000000000000000000000000000011111111111100001011110111000001
1101 << 0010=0100
1101 >>_a 0010=1111
1101 >>_l 0010=0011
1001 /_s 0010 =1101
1001 /_u 0010 =0100
0111 %_s 0011 =0001 (1) 
0111 %_s 1101 =0001 (1) 
1001 %_s 0011 =1111 (-1) 
1001 %_s 1101 =1111 (-1) 
0111 %_u 0011 =0001
0111 %_u 1101 =0111
1001 %_s 0011 =0000
1001 %_s 1101 =1001
UMAX(64)=18446744073709551615
1111111111111111111111111111111111111111111111111111111111111111
UMIN(64)=0
0000000000000000000000000000000000000000000000000000000000000000
SMAX(64)=9223372036854775807
0111111111111111111111111111111111111111111111111111111111111111
SMIN(64)=9223372036854775808
1000000000000000000000000000000000000000000000000000000000000000
UMAX(32)=4294967295
11111111111111111111111111111111
UMIN(32)=0
00000000000000000000000000000000
SMAX(32)=2147483647
01111111111111111111111111111111
SMIN(32)=2147483648
10000000000000000000000000000000
UMAX(40)=1099511627775
1111111111111111111111111111111111111111
UMIN(40)=0
0000000000000000000000000000000000000000
SMAX(40)=549755813887
0111111111111111111111111111111111111111
SMIN(40)=549755813888
1000000000000000000000000000000000000000
UMAX(63)=9223372036854775807
111111111111111111111111111111111111111111111111111111111111111
UMIN(63)=0
000000000000000000000000000000000000000000000000000000000000000
SMAX(63)=4611686018427387903
011111111111111111111111111111111111111111111111111111111111111
SMIN(63)=4611686018427387904
100000000000000000000000000000000000000000000000000000000000000
=== End ./test-bin/wrapint ===
=== Begin ./test-bin/wrapped_interval_domain ===
entry:
  y = -10;
  havoc(nd);
  goto bb_nd;
bb_nd:
  goto bb_nd_tt,bb_nd_ff;
bb_nd_tt:
  assume(-nd <= -1);
  x = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(-x+y <= 0);
  goto bb2;
bb2:
  x = x-y;
  goto bb1;
bb1_f:
  assume(x-y <= -1);
  goto ret;
ret:

bb_nd_ff:
  assume(nd <= 0);
  x = 100;
  goto bb1;

Invariants using Intervals
entry={}
bb_nd={y -> [-10, -10]}
bb_nd_ff={y -> [-10, -10]}
bb1={x -> [0, +oo]; y -> [-10, -10]}
bb1_f={x -> [0, +oo]; y -> [-10, -10]}
ret=_|_
bb1_t={x -> [0, +oo]; y -> [-10, -10]}
bb2={x -> [0, +oo]; y -> [-10, -10]}
bb_nd_tt={y -> [-10, -10]}
Abstract trace: entry bb_nd bb_nd_ff bb_nd_tt (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using WrappedIntervals
entry={}
bb_nd={y -> [[-10, -10]]_8}
bb_nd_ff={y -> [[-10, -10]]_8}
bb1={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
bb1_f={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
ret={x -> [[-128, -119]]_8; y -> [[-10, -10]]_8}
bb1_t={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
bb2={x -> [[0, 127]]_8; y -> [[-10, -10]]_8}
bb_nd_tt={y -> [[-10, -10]]_8}
Abstract trace: entry bb_nd bb_nd_ff bb_nd_tt (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  x = 127;
  x = x+1;
  goto if,then;
if:
  assume(x <= 1);
  x = 10;
  goto ret;
ret:

then:
  assume(-x <= -2);
  x = -10;
  goto ret;

Invariants using WrappedIntervals
entry={}
then={x -> [[-128, -128]]_8}
ret={x -> [[10, 10]]_8}
if={x -> [[-128, -128]]_8}
Abstract trace: entry then if ret

=== End ./test-bin/wrapped_interval_domain ===
=== Begin ./test-bin/wrapped_intervals ===
i1=[[-10, 10]]_8
i2=[[0, 20]]_8
-i2=[[-20, 0]]_8
i1 & i2: [[0, 10]]_8
i1 | i2: [[-10, 20]]_8
[[0, -10]]_8 & [[-15, 5]]_8: [[-15, 5]]_8
[[0, -10]]_8 | [[-15, 5]]_8: top
urk: [[1642571628, 700177772]]_32
urk.is_top(): 0
urk == Top: 0
[[-1, -7]]_4 * [[0, 1]]_4 = [[-1, -7]]_4
[[4, 7]]_4 /_s [[-2, 3]]_4 = [[1, -2]]_4
[[4, 7]]_4 /_u [[-2, 3]]_4 = [[0, 7]]_4
[[4, 7]]_4 /_s [[2, 2]]_4 = [[2, 3]]_4
[[4, 7]]_4 /_u [[2, 2]]_4 = [[2, 3]]_4
=== End ./test-bin/wrapped_intervals ===
