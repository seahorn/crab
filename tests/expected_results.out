INITIALLY={}
ADDING CONSTRAINTS={-x <= -1; x <= 1}
EXPECTED={x = 1}
RESULT={x = 1}
------------------------------------
INITIALLY={}
ADDING CONSTRAINTS={-x <= -1/2; x <= 1/2}
EXPECTED={x = 1/2}
RESULT=_|_
entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 100]; k -> [0, +oo]}
bb1_f={i -> [0, 100]; k -> [0, +oo]}
ret={i -> [100, 100]; k -> [0, +oo]}
bb1_t={i -> [0, 100]; k -> [0, +oo]}
bb2={i -> [0, 99]; k -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Invariants using ApronIntervals
entry={}
bb1={-i <= 0; i <= 100; -k <= 0}
bb1_f={-i <= 0; i <= 100; -k <= 0}
ret={i = 100; -k <= 0}
bb1_t={-i <= 0; i <= 100; -k <= 0}
bb2={-i <= 0; i <= 99; -k <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ApronOctagon
entry={}
bb1={-i <= 0; i <= 100; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 200; -i+k <= 0; k <= 100}
bb1_f={-i <= 0; i <= 100; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 200; -i+k <= 0; k <= 100}
ret={-i <= -100; i <= 100; i-k <= 0; -i-k <= -200; -k <= -100; i+k <= 200; -i+k <= 0; k <= 100}
bb1_t={-i <= 0; i <= 100; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 200; -i+k <= 0; k <= 100}
bb2={-i <= 0; i <= 99; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 198; -i+k <= 0; k <= 99}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ApronNewPolka
entry={}
bb1={-i+k = 0; i <= 100; -i <= 0}
bb1_f={-i+k = 0; i <= 100; -i <= 0}
ret={k = 100; i = 100}
bb1_t={-i+k = 0; i <= 100; -i <= 0}
bb2={-i+k = 0; i <= 99; -i <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  goto loop1_bb2;
loop1_bb2:
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  goto loop2_entry;
loop2_entry:
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  goto loop2_bb2;
loop2_bb2:
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_entry={i -> [10, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb2={i -> [10, 10]; j -> [0, 9]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
loop1_bb2={i -> [0, 9]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Invariants using ApronIntervals
loop1_entry={}
loop1_bb1={-i <= 0; i <= 10; k = 30}
loop1_bb1_f={-i <= 0; i <= 10; k = 30}
loop2_entry={i = 10; k = 30}
loop2_bb1={i = 10; -j <= 0; j <= 10; k = 30}
loop2_bb1_f={i = 10; -j <= 0; j <= 10; k = 30}
ret={i = 10; j = 10; k = 30}
loop2_bb1_t={i = 10; -j <= 0; j <= 10; k = 30}
loop2_bb2={i = 10; -j <= 0; j <= 9; k = 30}
loop1_bb1_t={-i <= 0; i <= 10; k = 30}
loop1_bb2={-i <= 0; i <= 9; k = 30}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Invariants using ApronOctagon
loop1_entry={}
loop1_bb1={-i <= 0; i <= 10; i-k <= -20; -i-k <= -30; -k <= -30; i+k <= 40; -i+k <= 30; k <= 30}
loop1_bb1_f={-i <= 0; i <= 10; i-k <= -20; -i-k <= -30; -k <= -30; i+k <= 40; -i+k <= 30; k <= 30}
loop2_entry={-i <= -10; i <= 10; i-k <= -20; -i-k <= -40; -k <= -30; i+k <= 40; -i+k <= 20; k <= 30}
loop2_bb1={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 30; k <= 30}
loop2_bb1_f={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 30; k <= 30}
ret={-i <= -10; i <= 10; i-j <= 0; -i-j <= -20; -j <= -10; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -40; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 20; k <= 30}
loop2_bb1_t={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 30; k <= 30}
loop2_bb2={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 19; -i+j <= -1; j <= 9; i-k <= -20; -i-k <= -40; j-k <= -21; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 39; -j+k <= 30; k <= 30}
loop1_bb1_t={-i <= 0; i <= 10; i-k <= -20; -i-k <= -30; -k <= -30; i+k <= 40; -i+k <= 30; k <= 30}
loop1_bb2={-i <= 0; i <= 9; i-k <= -21; -i-k <= -30; -k <= -30; i+k <= 39; -i+k <= 30; k <= 30}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Invariants using ApronNewPolka
loop1_entry={}
loop1_bb1={k = 30; i <= 10; -i <= 0}
loop1_bb1_f={k = 30; i <= 10; -i <= 0}
loop2_entry={k = 30; i = 10}
loop2_bb1={k = 30; i = 10; j <= 10; -j <= 0}
loop2_bb1_f={k = 30; i = 10; j <= 10; -j <= 0}
ret={k = 30; j = 10; i = 10}
loop2_bb1_t={k = 30; i = 10; j <= 10; -j <= 0}
loop2_bb2={k = 30; i = 10; j <= 9; -j <= 0}
loop1_bb1_t={k = 30; i <= 10; -i <= 0}
loop1_bb2={k = 30; i <= 9; -i <= 0}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto cont;
cont:
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  goto loop2_body;
loop2_body:
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using ApronIntervals
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={-i <= -1; i <= 9}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={-i <= -1; i <= 9}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using ApronOctagon
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={-i <= -1; i <= 9}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={-i <= -1; i <= 9}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using ApronNewPolka
entry={}
loop1_head={i <= 8; -i <= 0}
loop1_f={i <= 8; -i <= 0}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i <= 8; -i <= 0}
loop1_body={i <= 8; -i <= 0}
loop1_body_f={i <= 9; -i <= -1}
loop1_body_x={i <= 8; -i <= 0}
loop1_body_t={i <= 9; -i <= -1}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  goto loop_body;
loop_body:
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop_head={i -> [0, 10]; p -> [0, +oo]}
loop_f={i -> [0, 10]; p -> [0, +oo]}
ret={i -> [10, 10]; p -> [0, +oo]}
loop_t={i -> [0, 10]; p -> [0, +oo]}
loop_body={i -> [0, 9]; p -> [0, +oo]}
Abstract trace: entry (loop_head loop_t loop_body)^{4} loop_f ret

Invariants using ApronIntervals
entry={}
loop_head={-i <= 0; i <= 10; -p <= 0}
loop_f={-i <= 0; i <= 10; -p <= 0}
ret={i = 10; -p <= 0}
loop_t={-i <= 0; i <= 10; -p <= 0}
loop_body={-i <= 0; i <= 9; -p <= 0}
Abstract trace: entry (loop_head loop_t loop_body)^{3} loop_f ret

Invariants using ApronOctagon
entry={}
loop_head={-i <= 0; i <= 10; i-p <= 0; -i-p <= 0; -p <= 0}
loop_f={-i <= 0; i <= 10; i-p <= 0; -i-p <= 0; -p <= 0}
ret={-i <= -10; i <= 10; i-p <= 0; -i-p <= -20; -p <= -10}
loop_t={-i <= 0; i <= 10; i-p <= 0; -i-p <= 0; -p <= 0}
loop_body={-i <= 0; i <= 9; i-p <= 0; -i-p <= 0; -p <= 0}
Abstract trace: entry (loop_head loop_t loop_body)^{3} loop_f ret

Invariants using ApronNewPolka
entry={}
loop_head={-4*i+p = 0; i <= 10; -i <= 0}
loop_f={-4*i+p = 0; i <= 10; -i <= 0}
ret={p = 40; i = 10}
loop_t={-4*i+p = 0; i <= 10; -i <= 0}
loop_body={-4*i+p = 0; i <= 9; -i <= 0}
Abstract trace: entry (loop_head loop_t loop_body)^{3} loop_f ret

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i != 9);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(i = 9);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, +oo]; k -> [0, +oo]}
bb1_f={i -> [0, +oo]; k -> [0, +oo]}
ret={i -> [9, 9]; k -> [0, +oo]}
bb1_t={i -> [0, +oo]; k -> [0, +oo]}
bb2={i -> [0, +oo]; k -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Invariants using ApronIntervals
entry={}
bb1={-i <= 0; -k <= 0}
bb1_f={-i <= 0; -k <= 0}
ret={i = 9; -k <= 0}
bb1_t={-i <= 0; -k <= 0}
bb2={-i <= 0; -k <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ApronOctagon
entry={}
bb1={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
bb1_f={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
ret={-i <= -9; i <= 9; i-k <= 0; -i-k <= -18; -k <= -9; i+k <= 18; -i+k <= 0; k <= 9}
bb1_t={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
bb2={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ApronNewPolka
entry={}
bb1={-i+k = 0; -i <= 0}
bb1_f={-i+k = 0; -i <= 0}
ret={k = 9; i = 9}
bb1_t={-i+k = 0; -i <= 0}
bb2={-i+k = 0; -i <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

===================================
 Test 1 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
bb2={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t4[_x4], Mem[2...5] -> t3[_x3], Mem[6...9] -> t1[_x1], Mem[10...13] -> t4[_x4]}{_x0 -> [2, 2]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x3 -> [5, 5]; _x4 -> [7, 7]}
bb3={x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y4], Mem[2...5] -> t4[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y4]}{_y0 -> [2, 2]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [5, 5]; _y4 -> [7, 7]}
bb1={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t4[_x4], Mem[2...5] -> t3[_x3], Mem[6...9] -> t1[_x1], Mem[10...13] -> t4[_x4]}{_x0 -> [2, 2]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x3 -> [5, 5]; _x4 -> [7, 7]}
Abstract trace: bb0 bb2 bb1 bb3
 --- SAFE --------------------
Property : tmp1-tmp2 = -2
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y4], tmp1 -> t4[_y3], tmp2 -> t3[_y4], Mem[2...5] -> t4[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y4]}{_y0 -> [2, 2]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [5, 5]; _y4 -> [7, 7]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 2 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
bb2={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t3[_x4], Mem[6...9] -> t1[_x1], Mem[10...13] -> t3[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x4 -> [7, 7]}
bb3={x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]}
bb1={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t3[_x4], Mem[6...9] -> t1[_x1], Mem[10...13] -> t3[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x4 -> [7, 7]}
Abstract trace: bb0 bb2 bb1 bb3
 --- WARNING -----------------
Property : tmp1-tmp2 = -1
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], tmp2 -> t1[_y1], tmp3 -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 = -1
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], tmp1 -> t4[_y4], tmp2 -> t1[_y1], tmp3 -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]; _y4 -> [5, 5]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 3 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
bb2={x -> t0[_x0], x1 -> t0[_x0], x2 -> t1[_x1], x3 -> t2[_x2], x4 -> t3[_x3], val -> t4[_x4], Mem[4...11] -> t4[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [8, 8]; _x3 -> [10, 10]; _x4 -> [0, 0]}
bb3={x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]}
bb1={x -> t0[_x0], x1 -> t0[_x0], x2 -> t1[_x1], x3 -> t2[_x2], x4 -> t3[_x3], val -> t4[_x4], Mem[4...11] -> t4[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [8, 8]; _x3 -> [10, 10]; _x4 -> [0, 0]}
Abstract trace: bb0 bb2 bb1 bb3
 --- WARNING -----------------
Property : tmp1 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp2 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp3 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], tmp2 -> t6[_y6], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]; _y6 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp4 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], tmp2 -> t6[_y6], tmp3 -> t7[_y7], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]; _y6 -> [0, 0]; _y7 -> [0, 0]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
0  Number of total safe checks
0  Number of total error checks
4  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 4 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], *i -> t6[_y6], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [10, 10]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 9]; _x7 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], *i -> t6[_y6], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 9]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 5 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t13[_y12], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y8 -> [224, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [10, 10]; _y13 -> [0, 0]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [0, 9]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t13[_y12], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y8 -> [224, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 9]; _y13 -> [0, 0]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 6 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t10[_y1], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [10, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 9]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t10[_y1], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 9]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 7 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
entry={}
ret={x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 < 0
Invariant: {x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 < 0
Invariant: {x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 8 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
entry={}
ret={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 < 0
Invariant: {x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 < 0
Invariant: {x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 9 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
entry={}
ret={m1_lb -> t0[_x0], m1_ub -> t1[_x1], x -> t3[_x3], y -> t4[_x4], tmp1 -> t2[_x2], tmp2 -> t2[_x2], Mem1[20...23] -> t2[_x2], Mem1[24...27] -> t2[_x2], Mem1[28...31] -> t2[_x2], Mem1[32...35] -> t2[_x2], Mem1[36...39] -> t2[_x2], Mem1[40...43] -> t2[_x2], Mem1[44...47] -> t2[_x2], Mem1[48...51] -> t2[_x2], Mem1[52...55] -> t2[_x2], Mem1[56...59] -> t2[_x2], Mem1[60...63] -> t2[_x2], Mem1[64...67] -> t2[_x2], Mem1[68...71] -> t2[_x2], Mem1[72...75] -> t2[_x2], Mem1[76...79] -> t2[_x2]}{_x0 -> [20, 20]; _x1 -> [80, 80]; _x2 -> [42, 42]; _x3 -> [24, 24]; _x4 -> [76, 76]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 = 0
Invariant: {m1_lb -> t0[_x0], m1_ub -> t1[_x1], x -> t3[_x3], y -> t4[_x4], tmp1 -> t2[_x2], tmp2 -> t2[_x2], Mem1[20...23] -> t2[_x2], Mem1[24...27] -> t2[_x2], Mem1[28...31] -> t2[_x2], Mem1[32...35] -> t2[_x2], Mem1[36...39] -> t2[_x2], Mem1[40...43] -> t2[_x2], Mem1[44...47] -> t2[_x2], Mem1[48...51] -> t2[_x2], Mem1[52...55] -> t2[_x2], Mem1[56...59] -> t2[_x2], Mem1[60...63] -> t2[_x2], Mem1[64...67] -> t2[_x2], Mem1[68...71] -> t2[_x2], Mem1[72...75] -> t2[_x2], Mem1[76...79] -> t2[_x2]}{_x0 -> [20, 20]; _x1 -> [80, 80]; _x2 -> [42, 42]; _x3 -> [24, 24]; _x4 -> [76, 76]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 10 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
bb2={Mem1[2...5] -> t0[_x0]}{_x0 -> [42, 42]}
bb3={Mem1[2...5] -> t0[_y0]}{_y0 -> [42, 42]}
bb4={x -> t0[_y1], Mem1[2...5] -> t0[_y1]}{_y1 -> [42, 42]}
bb1={Mem1[2...5] -> t0[_x0]}{_x0 -> [42, 42]}
Abstract trace: bb0 bb2 bb1 bb3 bb4
 --- WARNING -----------------
Property : x = 42
Invariant: {x -> t0[_y1], Mem1[2...5] -> t0[_y1]}{}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 11 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
bb2={Mem1[2...5] -> t0[_x0], Mem2[2...5] -> t1[_x1], Mem1[6...9] -> t2[_x2]}{_x0 -> [42, 42]; _x1 -> [666, 666]; _x2 -> [50, 50]}
bb3={i -> t0[_y3], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
bb4={i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
bb1={Mem1[2...5] -> t0[_x0], Mem2[2...5] -> t1[_x1], Mem1[6...9] -> t2[_x2]}{_x0 -> [42, 42]; _x1 -> [666, 666]; _x2 -> [50, 50]}
Abstract trace: bb0 bb2 bb1 bb3 bb4
 --- SAFE --------------------
Property : x = 42
Invariant: {i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
 -----------------------------
 --- SAFE --------------------
Property : y = 50
Invariant: {i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 12 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
Abstract trace: bb0
 --- SAFE --------------------
Property : x = 42
Invariant: {x -> t0[_x0], y -> t1[_x1], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t1[_x1]}{_x0 -> [42, 42]; _x1 -> [50, 50]}
 -----------------------------
 --- SAFE --------------------
Property : y = 50
Invariant: {x -> t0[_x0], y -> t1[_x1], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t1[_x1]}{_x0 -> [42, 42]; _x1 -> [50, 50]}
 -----------------------------
 --- SAFE --------------------
Property : x = 666
Invariant: {i -> t2[_x2], j -> t3[_x3], x -> t4[_x4], y -> t4[_x4], Mem1[0...3] -> t4[_x4], Mem1[4...7] -> t4[_x4]}{_x2 -> [0, 0]; _x3 -> [8, 8]; _x4 -> [666, 666]}
 -----------------------------
 --- SAFE --------------------
Property : y = 666
Invariant: {i -> t2[_x2], j -> t3[_x3], x -> t4[_x4], y -> t4[_x4], Mem1[0...3] -> t4[_x4], Mem1[4...7] -> t4[_x4]}{_x2 -> [0, 0]; _x3 -> [8, 8]; _x4 -> [666, 666]}
 -----------------------------
 --- WARNING -----------------
Property : y = 666
Invariant: {i -> t1[_x5], j -> t3[_x3], x -> t2[_x6], y -> t0[_x7], Mem1[0...3] -> t2[_x6], Mem1[4...7] -> t0[_x7]}{_x3 -> [8, 8]; _x5 -> [2, 2]}
 -----------------------------
 --- WARNING -----------------
Property : x = 666
Invariant: {i -> t1[_x5], j -> t3[_x3], x -> t2[_x7], y -> t0[_x6], Mem1[0...3] -> t2[_x7], Mem1[4...7] -> t0[_x6]}{_x3 -> [8, 8]; _x5 -> [2, 2]; _x6 -> [666, 666]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
4  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 13 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
Abstract trace: bb0
 --- SAFE --------------------
Property : x = 42
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t0[_x0], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [16, 16]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [16, 16]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [16, 16]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [16, 16]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 50
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t2[_x2], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [16, 16]; _x5 -> [0, 0]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
5  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Program 1: forall 0<= i< 10. a[i] = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
ret={n1 -> [1, 1]; i -> [10, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
bb1_f={n1 -> [1, 1], i -> [0, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
ret={n1 -> [1, 1], i -> [10, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
bb1_t={n1 -> [1, 1], i -> [0, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
bb2={n1 -> [1, 1], i -> [0, 9], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
ret={n1 -> [1, 1]; i -> [10, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
bb1_f={n1 -> [1, 1], i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
ret={n1 -> [1, 1], i -> [10, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
bb1_t={n1 -> [1, 1], i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
bb2={n1 -> [1, 1], i -> [0, 9], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
ret={n1 -> [1, 1]; i -> [10, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
bb1_f={n1 -> [1, 1], i -> [0, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
ret={n1 -> [1, 1], i -> [10, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
bb1_t={n1 -> [1, 1], i -> [0, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
bb2={n1 -> [1, 1], i -> [0, 9], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={n1 -> [1, 1]; i -> [1, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=0, A-n<=123455}
bb1_f={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=0, A-n<=123455}
ret={n1 -> [1, 1], i -> [1, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, n-i<=0, i-n<=0, A-n<=123455}
bb1_t={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=0, A-n<=123455}
bb2={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=-1, A-n<=123454, n1-n<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 5: for all 0<= i< 10. a[i] = 123456 (assume elem size of 4 bytes)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={i -> [10, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={i -> [0, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
bb1_f={i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
ret={i -> [10, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
bb1_t={i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
bb2={i -> [0, 9], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
bb1_f={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
ret={n1 -> [1, 1]; i -> [2, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
bb1_t={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
bb2={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=0}
bb1_f={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=0}
ret={n1 -> [1, 1], i -> [2, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, n-i<=0, i-n<=0}
bb1_t={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=0}
bb2={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=-1, n1-n<=-1}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={n1 -> [1, 1]; n2 -> [2, 2]; i -> [10, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 9]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
bb1_f={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
ret={n1 -> [1, 1], n2 -> [2, 2], i -> [10, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
bb1_t={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
bb2={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 9], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_f2={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_f={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
ret={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_f1={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_t={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb2={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb2b={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb2a={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=0, i1-n<=0, A-n<=1, n1-n<=0}
bb1_f2={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=0, i1-n<=0, A-n<=1, n1-n<=0}
bb1_f={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=0, i1-n<=0, A-n<=1, n1-n<=0}
ret={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=0, i1-n<=0, A-n<=1, n1-n<=0}
bb1_f1={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=0, i1-n<=0, A-n<=1, n1-n<=0}
bb1_t={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=0, i1-n<=0, A-n<=1, n1-n<=0}
bb2={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=-1, i1-n<=-1, A-n<=0, n1-n<=0}
bb2b={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=-1, i1-n<=-1, A-n<=0, n1-n<=0}
bb2a={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, i2-n<=-1, i1-n<=-1, A-n<=0, n1-n<=0}
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, -1]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [0, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A -> [0, 123456], A_p -> [0, 0]}
bb1_f={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A -> [0, 123456], A_p -> [0, 0]}
ret={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, -1], A -> [0, 123456], A_p -> [0, 0]}
bb1_t={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A -> [0, 123456], A_p -> [0, 0]}
bb2={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [0, 9], A -> [0, 123456], A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 10: forall 0<= i < n. is_not_null(a[i]) &&  is_not_null(b[i]) 
Invariants using ArraySmashing(Product(SplitDBM,Nullity))
entry=({}, {})
bb1=({i -> [0, +oo], n -> [1, +oo], i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
bb1_f=({i -> [0, +oo], n -> [1, +oo], i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
ret=({i -> [1, +oo], n -> [1, +oo], n-i<=0, i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
bb1_t=({i -> [0, +oo], n -> [1, +oo], i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
bb2=({i -> [0, +oo], n -> [1, +oo], i-n<=-1}, {A -> NN; B -> NN; obj1 -> NN})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 11: forall 0<= i< 10. a[i] = true and b[i] = false
Invariants using ArraySmashing(Product(Boolean,SparseDBM))
entry=({}, {})
bb1=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
bb1_f=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
ret=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=-9})
bb1_t=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
bb2=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 9], i-n1<=8, n1-i<=1})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 1: forall 0<= i< 10. a[i] = 123456Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [0,2)=>{A0 -> [123456, 123456]}, [0,1)=>{A0 -> [123456, 123456]}, [0,n1)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [1,2)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}, [n1,2)=>{A0 -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [0,2)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [0,1)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [0,n1)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,2)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,2)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [0,2)=>{A -> [8, 8]; B -> [5, 5]}, [0,1)=>{A -> [8, 8]; B -> [5, 5]}, [0,n1)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,2)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,2)=>{A -> [8, 8]; B -> [5, 5]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [1, +oo], n -> [1, +oo], n1-i<=1, n-i<=0, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [0,1)=>{A -> [123456, 123456]}, [0,n1)=>{A -> [123456, 123456]}, [0,n)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [1,n)=>{A -> [123456, 123456]}, [2,n)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}, [n1,n)=>{A -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=-1, n1-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 5: for all 0<= i< 10. a[i] = 123456 (assume elem size of 4 bytes)Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i -> [0, 10]},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [8,i)=>{A -> [123456, 123456]}, [9,i)=>{A -> [123456, 123456]}})
bb1_f=({i -> [0, 10]},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [8,i)=>{A -> [123456, 123456]}, [9,i)=>{A -> [123456, 123456]}})
ret=({i -> [10, 10]},{[0,i)=>{A -> [123456, 123456]}, [0,8)=>{A -> [123456, 123456]}, [0,1)=>{A -> [123456, 123456]}, [0,9)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [1,8)=>{A -> [123456, 123456]}, [1,9)=>{A -> [123456, 123456]}, [8,i)=>{A -> [123456, 123456]}, [8,9)=>{A -> [123456, 123456]}, [9,i)=>{A -> [123456, 123456]}})
bb1_t=({i -> [0, 10]},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [8,i)=>{A -> [123456, 123456]}, [9,i)=>{A -> [123456, 123456]}})
bb2=({i -> [0, 9]},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [8,i)=>{A -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=0},{[0,n1)=>{A -> [89, 89]}, [0,1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
bb1_f=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=0},{[0,n1)=>{A -> [89, 89]}, [0,1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
ret=({n1 -> [1, 1], i -> [2, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, n-i<=0, i-n<=0},{[0,n1)=>{A -> [89, 89]}, [0,1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [0,2)=>{A -> [89, 89]}, [0,n)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [1,2)=>{A -> [89, 89]}, [1,n)=>{A -> [89, 89]}, [2,n)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}, [n1,2)=>{A -> [89, 89]}, [n1,n)=>{A -> [89, 89]}})
bb1_t=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=0},{[0,n1)=>{A -> [89, 89]}, [0,1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
bb2=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=-1, n1-n<=-1},{[0,n1)=>{A -> [89, 89]}, [0,1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
bb1_f=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
ret=({n1 -> [1, 1], n2 -> [2, 2], i -> [10, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
bb1_t=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
bb2=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 9], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb1_f2=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb1_f=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i1,1)=>{A -> [2, 2]}, [i1,n)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}, [i2,1)=>{A -> [1, 1]}, [i2,n)=>{A -> [1, 1]}})
ret=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i1,1)=>{A -> [2, 2]}, [i1,n)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}, [i2,1)=>{A -> [1, 1]}, [i2,n)=>{A -> [1, 1]}})
bb1_f1=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb1_t=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb2=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=-1, i1-n<=-1},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb2b=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=-1, i1-n<=-1},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb3=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], val -> [1, 2], val-i2<=1, i2-n<=0, i1-n<=0},{[0,i2)=>{A -> [1, +oo]}, [0,i1)=>{A -> [-oo, 2]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,1)=>{A -> [2, 2]}, [i1,i2)=>{A -> [2, 2]}, [i2,1)=>{A -> [1, 1]}, [i2,i1)=>{A -> [1, 1]}})
bb2a=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=-1, i1-n<=-1},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a bb3)^{4} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i -> [-1, 9]},{})
bb1_f=({i -> [-1, 9]},{})
ret=({i -> [-1, -1]},{[0,10)=>{A -> [123456, 123456]}, [0,5)=>{A -> [123456, 123456]}, [0,6)=>{A -> [123456, 123456]}, [0,9)=>{A -> [123456, 123456]}, [5,10)=>{A -> [123456, 123456]}, [5,6)=>{A -> [123456, 123456]}, [5,9)=>{A -> [123456, 123456]}, [6,10)=>{A -> [123456, 123456]}, [6,9)=>{A -> [123456, 123456]}, [9,10)=>{A -> [123456, 123456]}})
bb1_t=({i -> [-1, 9]},{})
bb2=({i -> [0, 9]},{})
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret

Program 10: forall 0<= i < n. a[i] == 123456 (decrementing loop w/ temp vars)Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i -> [-1, 9]},{})
bb1_f=({i -> [-1, 9]},{})
ret=({i -> [-1, -1]},{[0,10)=>{A -> [123456, 123456]}, [0,5)=>{A -> [123456, 123456]}, [0,6)=>{A -> [123456, 123456]}, [0,9)=>{A -> [123456, 123456]}, [5,10)=>{A -> [123456, 123456]}, [5,6)=>{A -> [123456, 123456]}, [5,9)=>{A -> [123456, 123456]}, [6,10)=>{A -> [123456, 123456]}, [6,9)=>{A -> [123456, 123456]}, [9,10)=>{A -> [123456, 123456]}})
bb1_t=({i -> [-1, 9]},{})
bb2=({i -> [0, 9]},{})
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret

Program 11: forall 0<= i< 10. a[i] = 123456 (w/ temp vars)Invariants using ArraySparseGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [0,2)=>{A0 -> [123456, 123456]}, [0,1)=>{A0 -> [123456, 123456]}, [0,n1)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [1,2)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}, [n1,2)=>{A0 -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 12: forall 0<= i < n. is_not_null(a[i]) &&  is_not_null(b[i]) 
Invariants using ArraySparseGraph(Product(SplitDBM,Nullity),Nullity)
entry=(({}, {}),{})
bb1=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
bb1_f=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
ret=(({i -> [1, +oo], n -> [1, +oo], max -> [0, +oo], max-i<=-1, n-i<=0, max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}})
bb1_t=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
bb2=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=-1, n-max<=1, i-max<=0}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [0,i)=>{A -> NN}, [1,max)=>{A -> NN}, [1,i)=>{A -> NN}, [i,max)=>{A -> NN}})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  x = 0;
  goto header1;
header1:
  goto body1,exit1;
body1:
  x = x+y;
  goto header1;
exit1:
  goto ifxpos,ret;
ifxpos:
  assume(-x <= -1);
  goto header2;
header2:
  goto body2,exit2;
body2:
  y = y+x;
  goto header2;
exit2:
  assert(-y <= 0);
  goto ret;
ret:


Necessary preconditions using ApronIntervals
entry=_|_
header1=_|_
exit1=_|_
ret=_|_
ifxpos=_|_
header2=_|_
exit2=_|_
body2=_|_
body1=_|_

Necessary preconditions using ApronNewPolka
entry=_|_
header1=_|_
exit1=_|_
ret=_|_
ifxpos=_|_
header2=_|_
exit2=_|_
body2=_|_
body1=_|_

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Boxes
entry={}
bb1={-k <= -15; -i <= -14; i <= 100} or 
{-k <= -14; k <= 14; -i <= -14; i <= 14} or 
{-k <= -13; k <= 13; -i <= -13; i <= 13} or 
{-k <= -12; k <= 12; -i <= -12; i <= 12} or 
{-k <= -11; k <= 11; -i <= -11; i <= 11} or 
{-k <= -10; k <= 10; -i <= -10; i <= 10} or 
{-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
bb1_f={-k <= -15; -i <= -14; i <= 100} or 
{-k <= -14; k <= 14; -i <= -14; i <= 14} or 
{-k <= -13; k <= 13; -i <= -13; i <= 13} or 
{-k <= -12; k <= 12; -i <= -12; i <= 12} or 
{-k <= -11; k <= 11; -i <= -11; i <= 11} or 
{-k <= -10; k <= 10; -i <= -10; i <= 10} or 
{-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
ret={-k <= -15; -i <= -100; i <= 100}
bb1_t={-k <= -15; -i <= -14; i <= 100} or 
{-k <= -14; k <= 14; -i <= -14; i <= 14} or 
{-k <= -13; k <= 13; -i <= -13; i <= 13} or 
{-k <= -12; k <= 12; -i <= -12; i <= 12} or 
{-k <= -11; k <= 11; -i <= -11; i <= 11} or 
{-k <= -10; k <= 10; -i <= -10; i <= 10} or 
{-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
Abstract trace: entry (bb1 bb1_t)^{13} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using Boxes
loop1_entry={}
loop1_bb1={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop1_bb1_f={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop2_bb1={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 10}
loop2_bb1_f={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 10}
ret={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= -10; j <= 10}
loop2_bb1_t={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 10}
loop1_bb1_t={-k <= -30; k <= 30; -i <= 0; i <= 10}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{11} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{11} loop2_bb1_f ret

entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using Boxes
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={-i <= -1; i <= 9}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={-i <= -1; i <= 9}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{9} loop1_f (loop2_head loop2_t)^{1} loop2_f ret

entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Boxes
entry={}
loop_head={-i <= -10; i <= 10; -p <= -40; p <= 40} or 
{-i <= -9; i <= 9; -p <= -36; p <= 36} or 
{-i <= -8; i <= 8; -p <= -32; p <= 32} or 
{-i <= -7; i <= 7; -p <= -28; p <= 28} or 
{-i <= -6; i <= 6; -p <= -24; p <= 24} or 
{-i <= -5; i <= 5; -p <= -20; p <= 20} or 
{-i <= -4; i <= 4; -p <= -16; p <= 16} or 
{-i <= -3; i <= 3; -p <= -12; p <= 12} or 
{-i <= -2; i <= 2; -p <= -8; p <= 8} or 
{-i <= -1; i <= 1; -p <= -4; p <= 4} or 
{-i <= 0; i <= 0; -p <= 0; p <= 0}
loop_f={-i <= -10; i <= 10; -p <= -40; p <= 40} or 
{-i <= -9; i <= 9; -p <= -36; p <= 36} or 
{-i <= -8; i <= 8; -p <= -32; p <= 32} or 
{-i <= -7; i <= 7; -p <= -28; p <= 28} or 
{-i <= -6; i <= 6; -p <= -24; p <= 24} or 
{-i <= -5; i <= 5; -p <= -20; p <= 20} or 
{-i <= -4; i <= 4; -p <= -16; p <= 16} or 
{-i <= -3; i <= 3; -p <= -12; p <= 12} or 
{-i <= -2; i <= 2; -p <= -8; p <= 8} or 
{-i <= -1; i <= 1; -p <= -4; p <= 4} or 
{-i <= 0; i <= 0; -p <= 0; p <= 0}
ret={-i <= -10; i <= 10; -p <= -40; p <= 40}
loop_t={-i <= -10; i <= 10; -p <= -40; p <= 40} or 
{-i <= -9; i <= 9; -p <= -36; p <= 36} or 
{-i <= -8; i <= 8; -p <= -32; p <= 32} or 
{-i <= -7; i <= 7; -p <= -28; p <= 28} or 
{-i <= -6; i <= 6; -p <= -24; p <= 24} or 
{-i <= -5; i <= 5; -p <= -20; p <= 20} or 
{-i <= -4; i <= 4; -p <= -16; p <= 16} or 
{-i <= -3; i <= 3; -p <= -12; p <= 12} or 
{-i <= -2; i <= 2; -p <= -8; p <= 8} or 
{-i <= -1; i <= 1; -p <= -4; p <= 4} or 
{-i <= 0; i <= 0; -p <= 0; p <= 0}
Abstract trace: entry (loop_head loop_t)^{11} loop_f ret

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i != 9);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(i = 9);
  goto ret;
ret:


Invariants using Boxes
entry={}
bb1={-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
bb1_f={-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
ret={-k <= -9; k <= 9; -i <= -9; i <= 9}
bb1_t={-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
bb2={-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{10} bb1_f ret

entry:
  x = 1;
  y = 0;
  goto header;
header:
  goto body,exit;
body:
  x = x+y;
  y = y+1;
  goto header;
exit:
  assert(-x+y <= 0);


Invariants using Boxes
entry={}
header={-x <= -2; -y <= -1} or 
{-x <= -1; x <= 1; -y <= 0}
exit={-x <= -2; -y <= -1} or 
{-x <= -1; x <= 1; -y <= 0}
body={-x <= -2; -y <= -1} or 
{-x <= -1; x <= 1; -y <= 0}
Abstract trace: entry (header body)^{4} exit

Testing some boxes operations ...
{-y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y + z= 
{-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y - z= 
{-x <= 0; x <= 2; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= 1; x <= -1; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= 1; x <= -1; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= 4; x <= -2; -y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y * z= 
{-x <= -12; x <= 42; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -12; x <= 42; -y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y / z= 
{-x <= 0; x <= 1; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= 0; x <= 1; -y <= -3; y <= 3; -z <= -4; z <= 4}
INV: {-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
ADDED x >= y 
{-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
INV: {-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
ADDED x <= y + z -1
{-x <= -11; x <= 12; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
INV: {}
ADDED x != 9
{-x <= -10} or 
{x <= 8}
ADDED y >= 9
{-x <= -10; -y <= -9} or 
{x <= 8; -y <= -9}
ADDED y <= 9
{-x <= -10; -y <= -9; y <= 9} or 
{x <= 8; -y <= -9; y <= 9}
ADDED z > 9
{-x <= -10; -y <= -9; y <= 9; -z <= -10} or 
{x <= 8; -y <= -9; y <= 9; -z <= -10}
ADDED z < 9
_|_
OP1={-x <= -2; -y <= -2; y <= 2} or 
{-x <= -1; x <= 1; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= 0; y <= 0}
OP2={-x < -3; -y <= -3; y <= 3} or 
{-x <= -2; x <= 3; -y <= -3; y <= 3} or 
{-x <= -2; x <= 3; -y <= -2; y <= 2} or 
{-x <= -2; x <= 3; -y <= -1; y <= 1} or 
{-x < -1; x < 2; -y <= -2; y <= 2} or 
{-x < -1; x < 2; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= -2; y <= 2} or 
{-x <= -1; x <= 1; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= 0; y <= 0}
WIDENING(OP1,OP2)={-x < -3; -y <= -3} or 
{-x < -3; -y <= -2; y <= 2} or 
{-x <= -2; x <= 3; -y <= -3} or 
{-x <= -2; x <= 3; -y <= -2; y <= 2} or 
{-x <= -2; x <= 3; y <= 1} or 
{-x < -1; x < 2; -y <= -2; y <= 2} or 
{-x < -1; x < 2; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= -2} or 
{-x <= -1; x <= 1; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= 0; y <= 0}
[A] CONVEX(WIDENING(OP1,OP2))={-x <= -1}
--------------------------------
CONVEX(OP1)={x -> [1, +oo]; y -> [0, 2]}
CONVEX(OP2)={x -> [1, +oo]; y -> [0, 3]}
[B] WIDENING(CONVEX(OP1),CONVEX(OP2))={x -> [1, +oo]; y -> [0, +oo]}
--------------------------------
[A] and [B] should be the same if CONVEX distributes over WIDENING 
CFG
x0:
  k = 2147483648;
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Reversed CFG
ret:
--> [bb1_f;]
bb1_f:
  assume(-i <= -100);
--> [bb1;]
bb1:
--> [entry;bb2;]
entry:
  i = 0;
--> [x3;]
x3:
--> [x2;]
x2:
--> [x1;]
x1:
--> [x0;]
x0:
  k = 2147483648;
--> []
bb2:
  i = i+inc;
  inc = ite(-nd <= -1,1,2);
  havoc(nd);
--> [bb1_t;]
bb1_t:
  assume(i <= 99);
--> [bb1;]

Weak reversed topological order of CFG 
ret -- bb1_f -- bb2 -- bb1_t -- bb1 -- entry -- x3 -- x2 -- x1 -- x0
Weak topological order of the reversed CFG 
ret -- bb1_f -- bb1 -- bb2 -- bb1_t -- entry -- x3 -- x2 -- x1 -- x0
Bourdoncle WTO of the reversed CFG
ret bb1_f (bb1 bb2 bb1_t) entry x3 x2 x1 x0
Simplified CFG
x0:
  k = 2147483648;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Reversed simplified CFG
ret:
--> [bb1_f;]
bb1_f:
  assume(-i <= -100);
--> [bb1;]
bb1:
--> [x0;bb1_t;]
x0:
  i = 0;
  k = 2147483648;
--> []
bb1_t:
  i = i+inc;
  inc = ite(-nd <= -1,1,2);
  havoc(nd);
  assume(i <= 99);
--> [bb1;]

CFG
entry:
  goto x1;
x1:
  goto x2,x6,exit;
x2:
  goto x3,x4;
x3:
  goto x5;
x5:
  goto x1;
x4:
  goto x5;
x6:
  goto x7,x8;
x7:
  goto x9;
x9:
  goto exit;
exit:

x8:
  goto x9;

Control-dependence graph 
{x2;x5;x6;x9;}  control-dependent on x1
{x3;x4;}  control-dependent on x2
{x7;x8;}  control-dependent on x6
z:int declare foo(x:int)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;
  return z;


y:int declare bar(a:int)
entry:
  x = a;
  goto exit;
exit:
  y = call foo(x:int);
  return y;


void declare main()
entry:
  x = 3;
  y = call bar(x:int);
  goto exit;
exit:
  z = y+2;


CG=
bar--> foo
main--> bar

number of predecessors foo=1
bar-->foo
number of successors bar=1
bar-->foo
number of predecessors bar=1
main-->bar
number of successors main=1
main-->bar
Found root main
Printing in preorder ...
main
bar
foo
SCCG=
vertices={main;bar;foo;}
edges=
main--> bar
bar--> foo
reverse topological sort: foo--bar--main--
topological sort: main--bar--foo--
b0:
  p = &(1);
  q1 = &(2);
  q2 = &(3);
  havoc(nd);
  goto b1,b2;
b1:
  assume(-nd <= -1);
  *(p) = q1;
  goto b3;
b3:
  r = *(p);

b2:
  assume(nd <= 0);
  *(p) = q2;
  goto b3;

Analysis using Product(SplitDBM,Nullity)
b0=({}, {}) ==> ({}, {p -> NN; q1 -> NN; q2 -> NN})
b2=({}, {p -> NN; q1 -> NN; q2 -> NN}) ==> ({nd -> [-oo, 0]}, {p -> NN; q1 -> NN; q2 -> NN})
b3=({}, {p -> NN; q1 -> NN; q2 -> NN}) ==> ({}, {p -> NN; q1 -> NN; q2 -> NN})
b1=({}, {p -> NN; q1 -> NN; q2 -> NN}) ==> ({nd -> [1, +oo]}, {p -> NN; q1 -> NN; q2 -> NN})
Analysis using SplitDBM
b0={} ==> {}
b2={} ==> {nd -> [-oo, 0]}
b3={} ==> {}
b1={} ==> {nd -> [1, +oo]}
 --- SAFE --------------------
Property : p != 0
Invariant: ({}, {p -> NN; q1 -> NN; q2 -> NN})
 -----------------------------
 --- SAFE --------------------
Property : p != 0
Invariant: ({nd -> [-oo, 0]}, {p -> NN; q1 -> NN; q2 -> NN})
 -----------------------------
 --- SAFE --------------------
Property : p != 0
Invariant: ({nd -> [1, +oo]}, {p -> NN; q1 -> NN; q2 -> NN})
 -----------------------------
null-dereference checker
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
integer division by zero checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
user-defined assertion checker using SplitDBM
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Assertion Crawler Analysis 
entry={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb1={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb1_f={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
ret=_|_
bb1_t={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb2={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}


******* UNJUSTIFIED ASSUMPTION ANALYSIS ********
assert(-i <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a3 in x = x+y
	assume NotOverflow({y}) as a4 in y = y+1
	assume NotOverflow({i}) as a5 in i = i+1
assert(-x <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a9 in x = x+y
	assume NotOverflow({y}) as a10 in y = y+1
	assume NotOverflow({i}) as a11 in i = i+1
assert(-x+y <= 0) with unjustified assumptions:
	assume NotOverflow({x; y}) as a6 in x = x+y
	assume NotOverflow({y}) as a7 in y = y+1
	assume NotOverflow({i}) as a8 in i = i+1
assert(i = 100) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
	assume NotOverflow({i}) as a2 in i = i+1
******************* STATS **********************
BRUNCH_STAT Assertions 4
BRUNCH_STAT Assumptions 12
BRUNCH_STAT MaxAssumptionsPerAssertion 3
BRUNCH_STAT AvgAssumptionsPerAssertion 3



******* UNJUSTIFIED ASSUMPTION ANALYSIS ********
assert(-i <= -200) with unjustified assumptions:
	assume NotOverflow({i}) as a2 in i = i+1
assert(-x <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
assert(-x+y <= 0) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
assert(i = 100) with unjustified assumptions:
	assume NotOverflow({i}) as a2 in i = i+1
******************* STATS **********************
BRUNCH_STAT Assertions 4
BRUNCH_STAT Assumptions 6
BRUNCH_STAT MaxAssumptionsPerAssertion 2
BRUNCH_STAT AvgAssumptionsPerAssertion 1.5


entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assert(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


Analysis using Product(SplitDBM,Nullity)
entry=({}, {}) ==> ({i -> [0, 0], x -> [1, 1], y -> [0, 0]}, {p -> N})
bb1=({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {})
bb1_f=({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {})
ret=({i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> _|_
bb1_t=({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {})
bb2=({i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({y -> [1, 100], i -> [1, 100], x -> [1, +oo], i-y<=0, y-i<=0, y-x<=0, i-x<=0}, {p -> NN; q -> NN})
Analysis using SplitDBM
entry={} ==> {i -> [0, 0], x -> [1, 1], y -> [0, 0]}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
ret={i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> _|_
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {y -> [1, 100], i -> [1, 100], x -> [1, +oo], i-y<=0, y-i<=0, y-x<=0, i-x<=0}
null-dereference checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
 --- SAFE --------------------
Property : i = 100
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
 --- WARNING -----------------
Property : -i <= -200
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
integer division by zero checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
user-defined assertion checker using SplitDBM
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
2  Number of total unreachable checks
CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


After Dead Code Elimination
x0:
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Cloned CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k = *(q);
  return k;


After Dead Code Elimination
x0:
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k = *(q);
  return k;


Cloned CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k = *(q);
  return k;


entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using DisjunctiveIntervals
entry={}
bb1={i -> [0, 100]; k -> [0, +oo]}
bb1_f={i -> [0, 100]; k -> [0, +oo]}
ret={i -> [100, 100]; k -> [0, +oo]}
bb1_t={i -> [0, 100]; k -> [0, +oo]}
bb2={i -> [0, 99]; k -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

{x -> [5, 10]} does not entail x = 7
{x -> [5, 10]} does not entail x = 11
{x -> [5, 5], y -> [0, 10]} entails x = 5
{x -> [5, 5], y -> [0, 10]} does not entail x = 7
{x -> [5, 5], y -> [0, 10]} entails y != 42
z:int declare foo(x:int)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;
  return z;


y1:int declare bar(a:int)
entry:
  x1 = a;
  w1 = 5;
  goto exit;
exit:
  y1 = call foo(x1:int);
  return y1;


t:int declare rec1(s:int)
entry:
  r = s-1;
  goto exit;
exit:
  t = call rec2(r:int);
  return t;


t1:int declare rec2(s1:int)
entry:
  r1 = s1-1;
  goto exit;
exit:
  t1 = call rec1(r1:int);
  return t1;


w2:int declare main()
entry:
  x2 = 3;
  y2 = call bar(x2:int);
  z3 = call rec1(y2:int);
  goto exit;
exit:
  z2 = y2+2;
  w2 = call foo(z2:int);
  return w2;


Running summary domain=SparseDBM and forward domain=Intervals
z:int declare foo(x:int)
exit={x -> [3, 8]; y -> [4, 9]; z -> [6, 11]}
entry={x -> [3, 8]; y -> [4, 9]}
=================================
y1:int declare bar(a:int)
exit={a -> [3, 3]; x1 -> [3, 3]; y1 -> [6, 6]; w1 -> [5, 5]}
entry={a -> [3, 3]; x1 -> [3, 3]; w1 -> [5, 5]}
=================================
t:int declare rec1(s:int)
exit={}
entry={}
=================================
t1:int declare rec2(s1:int)
exit={}
entry={}
=================================
w2:int declare main()
exit={x2 -> [3, 3]; y2 -> [6, 6]; z2 -> [8, 8]; w2 -> [11, 11]}
entry={x2 -> [3, 3]; y2 -> [6, 6]}
=================================
Summary foo(IN:{x:int},OUT:{z:int}) ==>
{z-x<=3, x-z<=-3}
Summary bar(IN:{a:int},OUT:{y1:int}) ==>
{y1-a<=3, a-y1<=-3}
Summary rec1(IN:{s:int},OUT:{t:int}) ==>
{}
Summary rec2(IN:{s1:int},OUT:{t1:int}) ==>
{}
Running summary domain=ApronOctagon and forward domain=Intervals
z:int declare foo(x:int)
exit={x -> [3, 8]; y -> [4, 9]; z -> [6, 11]}
entry={x -> [3, 8]; y -> [4, 9]}
=================================
y1:int declare bar(a:int)
exit={a -> [3, 3]; x1 -> [3, 3]; y1 -> [6, 6]; w1 -> [5, 5]}
entry={a -> [3, 3]; x1 -> [3, 3]; w1 -> [5, 5]}
=================================
t:int declare rec1(s:int)
exit={}
entry={}
=================================
t1:int declare rec2(s1:int)
exit={}
entry={}
=================================
w2:int declare main()
exit={x2 -> [3, 3]; y2 -> [6, 6]; z2 -> [8, 8]; w2 -> [11, 11]}
entry={x2 -> [3, 3]; y2 -> [6, 6]}
=================================
Summary foo(IN:{x:int},OUT:{z:int}) ==>
{x-z <= -3; -x+z <= 3}
Summary bar(IN:{a:int},OUT:{y1:int}) ==>
{a-y1 <= -3; -a+y1 <= 3}
Summary rec1(IN:{s:int},OUT:{t:int}) ==>
{}
Summary rec2(IN:{s1:int},OUT:{t1:int}) ==>
{}
Running summary domain=Term(Intervals) and forward domain=Intervals
z:int declare foo(x:int)
exit={}
entry={}
=================================
y1:int declare bar(a:int)
exit={a -> [3, 3]; x1 -> [3, 3]; w1 -> [5, 5]}
entry={a -> [3, 3]; x1 -> [3, 3]; w1 -> [5, 5]}
=================================
t:int declare rec1(s:int)
exit={}
entry={}
=================================
t1:int declare rec2(s1:int)
exit={}
entry={}
=================================
w2:int declare main()
exit={x2 -> [3, 3]}
entry={x2 -> [3, 3]}
=================================
Summary foo(IN:{x:int},OUT:{z:int}) ==>
{x -> t0[_x2], z -> t4[_x4]}{_x0 -> [1, 1]; _x3 -> [2, 2]}
Summary bar(IN:{a:int},OUT:{y1:int}) ==>
{a -> t7[_y0], y1 -> t9[_y4]}{}
Summary rec1(IN:{s:int},OUT:{t:int}) ==>
{s -> t4[_y1], t -> t7[_y3]}{}
Summary rec2(IN:{s1:int},OUT:{t1:int}) ==>
{s1 -> t0[_x2]}{}
Running summary domain=ReducedProduct(Term(DisjunctiveIntervals),SplitDBM) and forward domain=ReducedProduct(Term(DisjunctiveIntervals),SplitDBM)
z:int declare foo(x:int)
exit=({x -> t0[_y0], y -> t2[_y2], z -> t4[_y4]}{_y0 -> [3, 3] | [8, 8]; _y1 -> [1, 1]; _y2 -> [4, 4] | [9, 9]; _y3 -> [2, 2]; _y4 -> [6, 6] | [11, 11]}, {x -> [3, 8], y -> [4, 9], z -> [6, 11], y-x<=1, z-x<=3, x-y<=-1, z-y<=2, y-z<=-2, x-z<=-3})
entry=({x -> t0[_y0], y -> t2[_y2]}{_y0 -> [3, 3] | [8, 8]; _y1 -> [1, 1]; _y2 -> [4, 4] | [9, 9]}, {x -> [3, 8], y -> [4, 9], y-x<=1, x-y<=-1})
=================================
y1:int declare bar(a:int)
exit=({a -> t7[_y0], x1 -> t7[_y0], y1 -> t9[_y4], w1 -> t8[_y2]}{_y0 -> [3, 3]; _y1 -> [3, 3]; _y2 -> [5, 5]; _y3 -> [3, 3]; _y4 -> [6, 6]}, {a -> [3, 3], x1 -> [3, 3], w1 -> [5, 5], y1 -> [6, 6], x1-a<=0, y1-a<=3, a-x1<=0, y1-x1<=3, a-y1<=-3, x1-y1<=-3})
entry=({a -> t0[_x0], x1 -> t0[_x0], w1 -> t1[_x1]}{_x0 -> [3, 3]; _x1 -> [5, 5]}, {x1 -> [3, 3], a -> [3, 3], w1 -> [5, 5], a-x1<=0, x1-a<=0})
=================================
t:int declare rec1(s:int)
exit=({r -> t6[_y0], s -> t4[_y1], t -> t7[_y3]}{}, {s-r<=1, r-s<=-1})
entry=({r -> t2[_x1], s -> t0[_x2]}{_x0 -> [1, 1]}, {s-r<=1, r-s<=-1})
=================================
t1:int declare rec2(s1:int)
exit=({r1 -> t7[_z0], s1 -> t5[_z1], t1 -> t8[_z3]}{}, {s1-r1<=1, r1-s1<=-1})
entry=({r1 -> t2[_x1], s1 -> t0[_x2]}{_x0 -> [1, 1]}, {s1-r1<=1, r1-s1<=-1})
=================================
w2:int declare main()
exit=({x2 -> t16[_y0], y2 -> t17[_y1], z2 -> t19[_y2], z3 -> t20[_y3], w2 -> t21[_y5]}{_y0 -> [3, 3]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y4 -> [8, 8]; _y5 -> [11, 11]}, {x2 -> [3, 3], y2 -> [6, 6], z2 -> [8, 8], w2 -> [11, 11], y2-x2<=3, x2-y2<=-3, w2-z2<=3, z2-w2<=-3})
entry=({x2 -> t7[_x0], y2 -> t8[_x1], z3 -> t9[_x3]}{_x0 -> [3, 3]; _x1 -> [6, 6]; _x2 -> [6, 6]}, {x2 -> [3, 3], y2 -> [6, 6], y2-x2<=3, x2-y2<=-3})
=================================
Summary foo(IN:{x:int},OUT:{z:int}) ==>
({x -> t0[_x2], z -> t4[_x4]}{_x0 -> [1, 1]; _x3 -> [2, 2]}, {z-x<=3, x-z<=-3})
Summary bar(IN:{a:int},OUT:{y1:int}) ==>
({a -> t7[_y0], y1 -> t9[_y4]}{}, {y1-a<=3, a-y1<=-3})
Summary rec1(IN:{s:int},OUT:{t:int}) ==>
({s -> t4[_y1], t -> t7[_y3]}{}, {})
Summary rec2(IN:{s1:int},OUT:{t1:int}) ==>
({s1 -> t0[_x2]}{}, {})
Join 
Widening 
Widening of 
{-x <= 0; x <= 1/4; -y <= -1/4; y <= 1/2}and
{-x <= -1/4; x <= 1; -y <= -1/8; y <= 1/4} or 
{-x <= 0; x <= 0; -y <= -1/2; y <= 1/2} = 
{-x < -1/4; -y <= -1/8; y <= 1/4} or 
{-x <= 0; x <= 1/4; y <= 1/2}
Analysis using SplitDBM
 --- SAFE --------------------
Property : i = 100
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
 --- WARNING -----------------
Property : -i <= -200
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
user-defined assertion checker using SplitDBM
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
2  Number of total unreachable checks
Before replacing safe assertions with assume statements
entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assert(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


After replacing safe assertions with assume statements
entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assume(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


b0:
  p = &(1);
  havoc(r);
  havoc(s);
  goto b1,b2;
b1:
  assume_ptr(r == NULL);
  assume_ptr(r == s);
  goto b3;
b3:

b2:
  assume_ptr(r != s);
  q = &(2);
  p = &(q) + 4;
  goto b3;

Invariants using Nullity
b0={}
b2={p -> NN}
b3={p -> NN}
b1={p -> NN}
Abstract trace: b0 b2 b1 b3

b0:
  p = &(1);
  q1 = &(2);
  q2 = &(3);
  havoc(nd);
  goto b1,b2;
b1:
  assume(-nd <= -1);
  *(p) = q1;
  goto b3;
b3:
  r = *(p);

b2:
  assume(nd <= 0);
  *(p) = q2;
  goto b3;

Invariants using Nullity
b0={}
b2={p -> NN; q1 -> NN; q2 -> NN}
b3={p -> NN; q1 -> NN; q2 -> NN}
b1={p -> NN; q1 -> NN; q2 -> NN}
Abstract trace: b0 b2 b1 b3

entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);


Invariants using Nullity
entry={}
bb1={}
bb1_f={}
ret={}
bb1_t={}
bb2={}
Abstract trace: entry (bb1 bb1_t bb2)^{2} bb1_f ret

entry:
  goto bb1,bb2;
bb1:
  assume(-x <= 0);
  y = x;
  goto bb3;
bb3:
  assume(-y <= -1);
  assert(x != 0);

bb2:
  assume(x <= -1);
  tmp = 0;
  y = tmp-x;
  goto bb3;

Necessary preconditions using ApronIntervals
entry=_|_
bb2=_|_
bb3=_|_
bb1=_|_

entry:
  goto bb1,bb2;
bb1:
  assume(-x <= -1);
  y = x;
  goto bb3;
bb3:
  assume(-y <= -6);

bb2:
  assume(x <= 0);
  tmp = 0;
  y = tmp-x;
  goto bb3;

Necessary preconditions using ApronIntervals
entry=_|_
bb2=_|_
bb3=_|_
bb1=_|_

Necessary preconditions using Boxes
entry={-x <= 5; x <= 0}
bb2={-x <= 5; x <= 0}
bb3={-x <= 5; x <= 0; -tmp <= 0; tmp <= 0; -y <= 0; y <= 5}
bb1={-x <= 5; x <= 0}

bb1:
  x = 0;
  y = 0;
  goto bb2;
bb2:
  goto bb3,bb4;
bb3:
  assume(x <= 99);
  x = x+1;
  y = y+1;
  goto bb2;
bb4:
  assume(-x <= -100);
  assert(y <= 100);


Necessary preconditions using ApronIntervals
bb1={}
bb2={-x <= 0; x <= 100; -y <= 0}
bb4={-x <= 0; x <= 100; -y <= 0}
bb3={-x <= 0; x <= 100; -y <= 0}

bb1:
  x = 0;
  goto bb2;
bb2:
  goto bb3,bb4;
bb3:
  assume(x <= 99);
  x = x+1;
  goto bb2;
bb4:
  assume(-x <= -100);
  assert(x <= 100);


Necessary preconditions using ApronIntervals
bb1=_|_
bb2=_|_
bb4=_|_
bb3=_|_

Necessary preconditions using Boxes
bb1={}
bb2={-x <= 0; x <= 100}
bb4={-x <= 0}
bb3={-x <= 0}

{x -> t2[_x2], y -> t0[_x0]}{_x0 -> [8, 8]; _x1 -> [5, 5]; _x2 -> [40, 40]} | {x -> t2[_x1], y -> t0[_x2]}{_x0 -> [5, 5]} = {x -> t2[_y2], y -> t0[_y0]}{_y1 -> [5, 5]}
{x -> t0[_x0]}{_x0 -> [1, 1]} | {x -> t1[_x1]}{_x0 -> [1, 1]; _x1 -> [2, 2]} = {x -> t0[_y0]}{_y0 -> [1, 2]}
Before project {x -> t0[_x0], y -> t0[_x0], z -> t1[_x1]}{_x0 -> [5, 5]; _x1 -> [9, 9]}
After project {x -> t0[_x0], y -> t0[_x0]}{_x0 -> [5, 5]}
x0:
  k = 50;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
x0={}
bb1={i -> [0, 100]; k -> [50, 50]}
bb1_f={i -> [0, 100]; k -> [50, 50]}
ret={i -> [100, 100]; k -> [50, 50]}
bb1_t={i -> [0, 100]; k -> [50, 50]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
x0={}
bb1={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
bb1_f={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
ret={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [100, 100]}
bb1_t={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

p0:
  x = 50;
  havoc(y);
  assume(-y <= 1);
  assume(y <= 1);
  z = x*y;
  goto p_pos,p_neg;
p_pos:
  assume(-y <= 0);
  goto exit;
exit:
  z0 = z;
  y0 = y;
  goto ret;
ret:

p_neg:
  assume(y <= -1);
  z = z*-1;
  goto exit;

Invariants using Intervals
p0={}
p_neg={y -> [-1, 1]; z -> [-50, 50]}
exit={y -> [-1, 1]; z -> [-50, 50]}
ret={y -> [-1, 1]; z -> [-50, 50]; z0 -> [-50, 50]; y0 -> [-1, 1]}
p_pos={y -> [-1, 1]; z -> [-50, 50]}
Abstract trace: p0 p_neg p_pos exit ret

Invariants using Term(Intervals)
p0={}
p_neg={y -> t1[_x1], z -> t2[_x2]}{_x0 -> [50, 50]; _x1 -> [-1, 1]; _x2 -> [-50, 50]}
exit={y -> t0[_y0], z -> t3[_y3]}{_y0 -> [-1, 1]; _y1 -> [-50, 50]; _y2 -> [-1, 1]; _y3 -> [0, 50]}
ret={y -> t0[_y0], z -> t3[_y3], z0 -> t3[_y3], y0 -> t0[_y0]}{_y0 -> [-1, 1]; _y1 -> [-50, 50]; _y2 -> [-1, 1]; _y3 -> [0, 50]}
p_pos={y -> t1[_x1], z -> t2[_x2]}{_x0 -> [50, 50]; _x1 -> [-1, 1]; _x2 -> [-50, 50]}
Abstract trace: p0 p_neg p_pos exit ret

entry:
  i = 0;
  x = 5;
  y = 5;
  z = 3;
  w = 3;
  s = 0;
  t = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd1);
  havoc(nd2);
  x = x&nd1;
  y = y&nd1;
  z = z|nd1;
  w = w|nd1;
  s = nd1^nd2;
  t = nd1^nd2;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 100]}
bb1_f={i -> [0, 100]}
ret={i -> [100, 100]}
bb1_t={i -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using SparseDBM
entry={}
bb1={i -> [0, 100]}
bb1_f={i -> [0, 100]}
ret={i -> [100, 100]}
bb1_t={i -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
entry={}
bb1={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
bb1_f={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
ret={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [100, 100]}
bb1_t={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Meet
{x -> t0[_x0], y -> t2[_x2], w -> t0[_x0], z -> t1[_x1]}{_x0 -> [5, 5]; _x1 -> [3, 3]; _x2 -> [8, 8]} 
 {x -> t2[_x2], y -> t0[_x0], w -> t0[_x0], z -> t1[_x1]}{_x0 -> [8, 8]; _x1 -> [2, 2]; _x2 -> [10, 10]}
Result=_|_
Meet
{x -> t0[_x0], y -> t2[_x2], w -> t0[_x0], z -> t1[_x1]}{_x0 -> [5, 8]; _x1 -> [1, 10]; _x2 -> [6, 18]} 
 {x -> t2[_x2], y -> t0[_x0], w -> t0[_x0], z -> t1[_x1]}{_x0 -> [2, 7]; _x1 -> [3, 5]; _x2 -> [5, 12]}
Result={x -> t8[_y0], y -> t8[_y0], w -> t8[_y0], z -> t7[_y3]}{_y0 -> [5, 8]; _y1 -> [6, 7]; _y2 -> [5, 7]; _y3 -> [3, 5]}
Added x-y = 0
{x -> t2[_x2], y -> t3[_x3], v0 -> t0[_x0], v1 -> t1[_x1]}{_x0 -> [0, 0]; _x1 -> [1, 1]; _x2 -> [1, 1]; _x3 -> [1, 1]}
Result={x -> t6[_x4], y -> t6[_x4], v0 -> t5[_x5], v1 -> t4[_x6]}{_x4 -> [1, 1]; _x5 -> [0, 0]; _x6 -> [1, 1]}
Added x-y != 0
Result=_|_
Test with arrays
{x -> t1[_x2], y -> t3[_x4], z -> t4[_x3], A -> t0[_x1], @V_8 -> t4[_x3]}{_x3 -> [42, 42]}
Added z = 42
Result={x -> t1[_x2], y -> t3[_x4], z -> t4[_x3], A -> t0[_x1], @V_8 -> t4[_x3]}{_x3 -> [42, 42]}
Added z = 5
Result=_|_
x0:
  k = 2147483648;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
x0={}
bb1={i -> [0, 101]; k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101]; k -> [2147483648, 2147483648]}
ret={i -> [100, 101]; k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101]; k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using SparseDBM
x0={}
bb1={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
bb1_f={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
ret={i -> [100, 101], k -> [2147483648, 2147483648], k-i<=2147483548, i-k<=-2147483547}
bb1_t={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using SplitDBM
x0={}
bb1={i -> [0, 101], k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101], k -> [2147483648, 2147483648]}
ret={i -> [100, 101], k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101], k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Product(Intervals,Congruences)
x0=({}, {})
bb1=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
bb1_f=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
ret=({i -> [100, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
bb1_t=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
x0={}
bb1={i -> t0[_z1], k -> t1[_z0]}{_z0 -> [2147483648, 2147483648]; _z1 -> [0, 101]}
bb1_f={i -> t0[_z1], k -> t1[_z0]}{_z0 -> [2147483648, 2147483648]; _z1 -> [0, 101]}
ret={i -> t0[_z1], k -> t1[_z0]}{_z0 -> [2147483648, 2147483648]; _z1 -> [100, 101]}
bb1_t={i -> t0[_z1], k -> t1[_z0]}{_z0 -> [2147483648, 2147483648]; _z1 -> [0, 101]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using DisjunctiveIntervals
x0={}
bb1={i -> [0, 101]; k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101]; k -> [2147483648, 2147483648]}
ret={i -> [100, 101]; k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101]; k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 5573204538870989/562949953421312);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 6136154492292301/562949953421312]}
bb1_f={i -> [0, 6136154492292301/562949953421312]}
ret={i -> [10, 6136154492292301/562949953421312]}
bb1_t={i -> [0, 6136154492292301/562949953421312]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using ApronNewPolka
entry={}
bb1={i <= 10; -i <= 0}
bb1_f={i <= 10; -i <= 0}
ret={i = 10}
bb1_t={i <= 10; -i <= 0}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using SparseDBM
loop1_entry={}
loop1_bb1={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
loop1_bb1_f={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
loop2_bb1={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
loop2_bb1_f={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
ret={i -> [10, 10], j -> [10, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=0, k-j<=20, i-k<=-20, j-k<=-20}
loop2_bb1_t={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
loop1_bb1_t={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using SplitDBM
loop1_entry={}
loop1_bb1={i -> [0, 10], k -> [30, 30]}
loop1_bb1_f={i -> [0, 10], k -> [30, 30]}
loop2_bb1={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
loop2_bb1_f={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
ret={i -> [10, 10], j -> [10, 10], k -> [30, 30]}
loop2_bb1_t={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
loop1_bb1_t={i -> [0, 10], k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using Product(Intervals,Congruences)
loop1_entry=({}, {})
loop1_bb1=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
loop1_bb1_f=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
loop2_bb1=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
loop2_bb1_f=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
ret=({i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}, {i -> 10; j -> 10; k -> 30})
loop2_bb1_t=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
loop1_bb1_t=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using Term(Intervals)
loop1_entry={}
loop1_bb1={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
loop1_bb1_f={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
loop2_bb1={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
loop2_bb1_f={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
ret={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [10, 10]}
loop2_bb1_t={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
loop1_bb1_t={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using DisjunctiveIntervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

entry:
  x = 0;
  y = 1/2;
  goto bb1;
bb1:
  x = x+y;
  y = y/2;
  goto bb1;

Invariants using Intervals
entry={}
bb1={x -> [0, +oo]; y -> [0, 1/2]}
Abstract trace: entry (bb1)^{4}

Invariants using ApronNewPolka
entry={}
bb1={x+2*y = 1; -x <= 0}
Abstract trace: entry (bb1)^{3}

Invariants using Boxes
entry={}
bb1={-x < 0; y <= 1/4} or 
{-x <= 0; x <= 0; -y <= -1/2; y <= 1/2} or 
{-x <= 0; x <= 0; y <= 1/4} or 
{x < 0; y <= 1/4}
Abstract trace: entry (bb1)^{4}

entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto cont;
cont:
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  goto loop2_body;
loop2_body:
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using SparseDBM
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using SplitDBM
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using Product(Intervals,Congruences)
entry=({}, {})
loop1_head=({i -> [0, 8]}, {})
loop1_f=({i -> [0, 8]}, {})
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t=({i -> [0, 8]}, {})
loop1_body=({i -> [0, 8]}, {})
loop1_body_f=({i -> [1, 9]}, {})
loop1_body_x=({i -> [0, 8]}, {})
loop1_body_t=({i -> [1, 9]}, {})
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using Term(Intervals)
entry={}
loop1_head={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_f={i -> t0[_z0]}{_z0 -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_body={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_body_f={i -> t2[_z2]}{_z0 -> [0, 8]; _z1 -> [1, 1]; _z2 -> [1, 9]}
loop1_body_x={i -> t0[_x0]}{_x0 -> [0, 8]}
loop1_body_t={i -> t2[_z2]}{_z0 -> [0, 8]; _z1 -> [1, 1]; _z2 -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using DisjunctiveIntervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

entry:
  x = 1;
  y = 0;
  goto header;
header:
  goto body,exit;
body:
  x = x+y;
  y = y+1;
  goto header;
exit:
  assert(-x+y <= 0);


Invariants using Intervals
entry={}
header={x -> [1, +oo]; y -> [0, +oo]}
exit={x -> [1, +oo]; y -> [0, +oo]}
body={x -> [1, +oo]; y -> [0, +oo]}
Abstract trace: entry (header body)^{3} exit

Invariants using ApronNewPolka
entry={}
header={}
exit={}
body={}
Abstract trace: entry (header body)^{6} exit

Invariants using Boxes
entry={}
header={}
exit={}
body={}
Abstract trace: entry (header body)^{6} exit

entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop_head={i -> [0, 10]; p -> [0, +oo]}
loop_f={i -> [0, 10]; p -> [0, +oo]}
ret={i -> [10, 10]; p -> [0, +oo]}
loop_t={i -> [0, 10]; p -> [0, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using SparseDBM
entry={}
loop_head={i -> [0, 10], p -> [0, +oo], i-p<=0}
loop_f={i -> [0, 10], p -> [0, +oo], i-p<=0}
ret={i -> [10, 10], p -> [10, +oo], i-p<=0}
loop_t={i -> [0, 10], p -> [0, +oo], i-p<=0}
Abstract trace: entry (loop_head loop_t)^{3} loop_f ret

Invariants using SplitDBM
entry={}
loop_head={i -> [0, 10], p -> [0, +oo], i-p<=0}
loop_f={i -> [0, 10], p -> [0, +oo], i-p<=0}
ret={i -> [10, 10], p -> [10, +oo], i-p<=0}
loop_t={i -> [0, 10], p -> [0, +oo], i-p<=0}
Abstract trace: entry (loop_head loop_t)^{3} loop_f ret

Invariants using Product(Intervals,Congruences)
entry=({}, {})
loop_head=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
loop_f=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
ret=({i -> [10, 10]; p -> [0, +oo]}, {i -> 10; p -> 4Z+0})
loop_t=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using Term(Intervals)
entry={}
loop_head={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
loop_f={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
ret={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [10, 10]; _y1 -> [0, +oo]}
loop_t={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using DisjunctiveIntervals
entry={}
loop_head={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
loop_f={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
ret={i -> [10, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
loop_t={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

entry:
  i = 0;
  x = 1;
  y = 0;
  z = 3;
  w = 3;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd1);
  havoc(nd2);
  x = x+y;
  y = y+1;
  z = z^nd1;
  w = w^nd1;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto exit;
exit:
  assume(x-y <= 0);
  goto ret;
ret:



Invariants using SparseDBM
entry={}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
exit={x -> [100, +oo], y -> [100, 100], y-x<=0}
ret={x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0}
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

Invariants using SplitDBM
entry={}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
exit={x -> [100, +oo], y -> [100, 100], y-x<=0}
ret={x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0}
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f exit ret

Invariants using Term(DisjunctiveIntervals)
entry={}
bb1={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
bb1_f={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
exit={x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [1, +oo]}
ret={x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [1, 100]}
bb1_t={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
bb2={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 99]; _y1 -> [1, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

Invariants using ReducedProduct(Term(DisjunctiveIntervals),SplitDBM)
entry=({}, {})
bb1=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
bb1_f=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
exit=({x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [100, +oo]}, {x -> [100, +oo], y -> [100, 100], y-x<=0, w-z<=0, z-w<=0})
ret=({x -> t3[_y3], y -> t3[_y3], z -> t0[_y4], w -> t0[_y4]}{_y3 -> [100, 100]}, {x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0, w-z<=0, z-w<=0})
bb1_t=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
bb2=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 99]; _y1 -> [1, +oo]}, {i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

entry:
  i = 0;
  bf = false ;
  bt = true ;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  b1 = (i <= 99);
  assume(b1);
  assert(b1);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  b3 = (-i <= -1);
  b4 = b3;
  b4 = b4|bf;
  b4 = b4&bt;
  b4 = b4^bt;
  b4 = b4^bt;
  goto bb1;
bb1_f:
  b2 = (-i <= -100);
  assume(b2);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, +oo]}
bb1_f={i -> [0, +oo]}
ret={i -> [0, +oo]}
bb1_t={i -> [0, +oo]}
bb2={i -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Product(Boolean,SparseDBM)
entry=({}, {})
bb1=({bf -> false; bt -> true}, {i -> [0, 101]})
bb1_f=({bf -> false; bt -> true}, {i -> [0, 101]})
ret=({b2 -> true; bf -> false; bt -> true}, {i -> [100, 101]})
bb1_t=({bf -> false; bt -> true}, {i -> [0, 101]})
bb2=({b1 -> true; bf -> false; bt -> true}, {i -> [0, 99]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Boxes
entry={}
bb1={-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1}
bb1_f={-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1}
ret={-i <= -100; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1; -b2 <= -1} or 
{-i <= -100; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1; -b2 <= -1}
bb1_t={-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1}
bb2={-i <= -1; i <= 99; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 99; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  i = 0;
  havoc(n);
  b = (n = 10);
  assume(b);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
bb1=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
bb1_f=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
ret=({b -> true}, {i -> [11, 11]; n -> [10, 10]})
bb1_t=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
bb2=({b -> true}, {i -> [0, 10]; n -> [10, 10]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  i = 0;
  havoc(n);
  b = (n = 10);
  goto bb0,entry_cnt;
bb0:
  n = 1;
  goto entry_cnt;
entry_cnt:
  assume(b);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
entry_cnt=({}, {i -> [0, 0]})
bb1=({b -> true}, {i -> [0, +oo]})
bb1_f=({b -> true}, {i -> [0, +oo]})
ret=({b -> true}, {i -> [0, +oo]})
bb1_t=({b -> true}, {i -> [0, +oo]})
bb2=({b -> true}, {i -> [0, +oo]; n -> [0, +oo]})
bb0=({}, {i -> [0, 0]})
Abstract trace: entry bb0 entry_cnt (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  i = 0;
  havoc(n);
  trunc n:64 to n1:32;
  b1 = (n1 = 9);
  assume(b1);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
bb1=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb1_f=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
ret=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb1_t=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb2=({b1 -> true}, {i -> [0, +oo]; n -> [0, +oo]; n1 -> [9, 9]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Product(Boolean,SparseDBM)
entry=({}, {})
bb1=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb1_f=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
ret=({b1 -> true}, {i -> [10, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=-1, n-i<=-1, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb1_t=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb2=({b1 -> true}, {i -> [0, 9], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=0, n-n1<=0, i-n1<=0})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  goto loop1_bb2;
loop1_bb2:
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  goto loop2_entry;
loop2_entry:
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  goto loop2_bb2;
loop2_bb2:
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Starting at the entry of CFG:
Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_entry={i -> [10, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb2={i -> [10, 10]; j -> [0, 9]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
loop1_bb2={i -> [0, 9]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Starting at the entry of the second loop:
Invariants using Intervals
loop1_entry=_|_
loop1_bb1=_|_
loop1_bb1_f=_|_
loop2_entry={}
loop2_bb1={j -> [0, 10]}
loop2_bb1_f={j -> [0, 10]}
ret={j -> [10, 10]}
loop2_bb1_t={j -> [0, 10]}
loop2_bb2={j -> [0, 9]}
loop1_bb1_t=_|_
loop1_bb2=_|_
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2) loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Starting at the middle of the second loop:
Invariants using Intervals
loop1_entry=_|_
loop1_bb1=_|_
loop1_bb1_f=_|_
loop2_entry=_|_
loop2_bb1={}
loop2_bb1_f={}
ret={j -> [10, +oo]}
loop2_bb1_t={}
loop2_bb2={}
loop1_bb1_t=_|_
loop1_bb2=_|_
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2) loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{1} loop2_bb1_f ret

Thresholds= {-oo,-999,-89,-10,0,5,10,100,1000,+oo}
next threshold for 3:5
next threshold for 8: 10
next threshold for 100: 1000
next threshold for 500: 1000
next threshold for 10000: +oo
next threshold for -4: 0
prev threshold for -4:-10
prev threshold for -78:-89
prev threshold for -10000:-oo
entry:
  n = 0;
  assume(y <= 878);
  goto loop1_header;
loop1_header:
  goto loop1_bb0,loop1_bb1,cont;
loop1_bb0:
  havoc(x);
  assume(-x <= 0);
  goto loop1_header;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(n <= 60);
  goto loop1_bb2;
loop1_bb2:
  n = n+1;
  goto loop1_bb4;
loop1_bb4:
  goto loop1_header;
loop1_bb1_f:
  assume(-n <= -61);
  goto loop1_bb3;
loop1_bb3:
  n = 0;
  goto loop1_bb4;
cont:
  n = 0;
  goto loop2_header;
loop2_header:
  goto loop2_bb0,loop2_bb1,ret;
loop2_bb0:
  havoc(x);
  assume(-x <= -10);
  goto loop2_header;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(n <= 160);
  goto loop2_bb2;
loop2_bb2:
  n = n+2;
  goto loop2_bb4;
loop2_bb4:
  goto loop2_header;
loop2_bb1_f:
  assume(-n <= -161);
  goto loop2_bb3;
loop2_bb3:
  n = 0;
  goto loop2_bb4;
ret:


Thresholds per loop 
loop2_header={-oo,-159,-8,0,2,162,+oo}
loop1_header={-oo,-59,0,2,62,880,+oo}

Invariants using Term(Intervals)
entry={}
loop1_header={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, +oo]; _z1 -> [-oo, 878]}
cont={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, +oo]; _z1 -> [-oo, 878]}
loop2_header={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, +oo]; _y1 -> [-oo, 878]}
ret={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, +oo]; _y1 -> [-oo, 878]}
loop2_bb1={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, +oo]; _y1 -> [-oo, 878]}
loop2_bb1_f={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, +oo]; _y1 -> [-oo, 878]}
loop2_bb3={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [161, +oo]; _y1 -> [-oo, 878]}
loop2_bb4={n -> t0[_x1], y -> t1[_x0]}{_x0 -> [-oo, 878]; _x1 -> [0, 162]}
loop2_bb1_t={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, +oo]; _y1 -> [-oo, 878]}
loop2_bb2={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 160]; _y1 -> [-oo, 878]}
loop2_bb0={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, +oo]; _y1 -> [-oo, 878]}
loop1_bb1={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, +oo]; _z1 -> [-oo, 878]}
loop1_bb1_f={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, +oo]; _z1 -> [-oo, 878]}
loop1_bb3={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [61, +oo]; _z1 -> [-oo, 878]}
loop1_bb4={n -> t0[_x1], y -> t1[_x0]}{_x0 -> [-oo, 878]; _x1 -> [0, 61]}
loop1_bb1_t={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, +oo]; _z1 -> [-oo, 878]}
loop1_bb2={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 60]; _z1 -> [-oo, 878]}
loop1_bb0={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, +oo]; _z1 -> [-oo, 878]}
Abstract trace: entry (loop1_header loop1_bb1 loop1_bb1_f loop1_bb3 loop1_bb1_t loop1_bb2 loop1_bb4 loop1_bb0)^{3} cont (loop2_header loop2_bb1 loop2_bb1_f loop2_bb3 loop2_bb1_t loop2_bb2 loop2_bb4 loop2_bb0)^{3} ret

Invariants using Term(Intervals)
entry={}
loop1_header={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 62]; _z1 -> [-oo, 878]}
cont={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 62]; _z1 -> [-oo, 878]}
loop2_header={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 162]; _y1 -> [-oo, 878]}
ret={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 162]; _y1 -> [-oo, 878]}
loop2_bb1={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 162]; _y1 -> [-oo, 878]}
loop2_bb1_f={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 162]; _y1 -> [-oo, 878]}
loop2_bb3={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [161, 162]; _y1 -> [-oo, 878]}
loop2_bb4={n -> t0[_x1], y -> t1[_x0]}{_x0 -> [-oo, 878]; _x1 -> [0, 162]}
loop2_bb1_t={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 162]; _y1 -> [-oo, 878]}
loop2_bb2={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 160]; _y1 -> [-oo, 878]}
loop2_bb0={n -> t0[_y0], y -> t1[_y1]}{_y0 -> [0, 162]; _y1 -> [-oo, 878]}
loop1_bb1={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 62]; _z1 -> [-oo, 878]}
loop1_bb1_f={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 62]; _z1 -> [-oo, 878]}
loop1_bb3={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [61, 62]; _z1 -> [-oo, 878]}
loop1_bb4={n -> t0[_x1], y -> t1[_x0]}{_x0 -> [-oo, 878]; _x1 -> [0, 61]}
loop1_bb1_t={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 62]; _z1 -> [-oo, 878]}
loop1_bb2={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 60]; _z1 -> [-oo, 878]}
loop1_bb0={n -> t0[_z0], y -> t1[_z1]}{_z0 -> [0, 62]; _z1 -> [-oo, 878]}
Abstract trace: entry (loop1_header loop1_bb1 loop1_bb1_f loop1_bb3 loop1_bb1_t loop1_bb2 loop1_bb4 loop1_bb0)^{3} cont (loop2_header loop2_bb1 loop2_bb1_f loop2_bb3 loop2_bb1_t loop2_bb2 loop2_bb4 loop2_bb0)^{3} ret

{A -> [0, +oo], x -> [0, 0], x-A<=0}
Before x != 0: {x -> [0, 10], y -> [0, 10], z -> [0, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, x-z<=0, y-z<=0}
After x != 0: {x -> [1, 10], y -> [1, 10], z -> [1, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, x-z<=0, y-z<=0}
Before x != 10: {x -> [0, 10], y -> [0, 10], z -> [0, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, u-v<=0, v-u<=0, x-z<=0, y-z<=0}
After x != 10: {x -> [0, 9], y -> [0, 9], z -> [0, 9], y-x<=0, z-x<=0, x-y<=0, z-y<=0, u-v<=0, v-u<=0, x-z<=0, y-z<=0}
DBM1={x -> [1, 1], y -> [1, 1], y-x<=0, x-y<=0}
DBM2={y -> [1, +oo]}
DBM1 & DBM2={y -> [1, 1], x -> [1, 1], x-y<=0, y-x<=0}
Bitwidth=3
5+7=4
5-7=6
5*7=3
1450 converted to 2
Bitwidth=8
5+7=12
5-7=254
5*7=35
224/2=240
5%7=5
Bitwidth=64
5+7=12
5-7=18446744073709551614
5*7=35
n1=0111
n2=1100
sext of n1 to 8 bits 00000111
sext of n2 to 8 bits 11111100
zext of n1 to 8 bits 00000111
zext of n2 to 8 bits 00001100
n=10101100
zext of n to 16 bits 0000000010101100
sext of n to 16 bits 1111111110101100
n1=00000000000000000000000000000111
n2=11111111111100001011110111000001
sext of n1 to 63 bits 000000000000000000000000000000000000000000000000000000000000111
sext of n2 to 63 bits 111111111111111111111111111111111111111111100001011110111000001
zext of n1 to 63 bits 000000000000000000000000000000000000000000000000000000000000111
zext of n2 to 63 bits 000000000000000000000000000000011111111111100001011110111000001
n1=00000000000000000000000000000111
n2=11111111111100001011110111000001
sext of n1 to 64 bits 0000000000000000000000000000000000000000000000000000000000000111
sext of n2 to 64 bits 1111111111111111111111111111111111111111111100001011110111000001
zext of n1 to 64 bits 0000000000000000000000000000000000000000000000000000000000000111
zext of n2 to 64 bits 0000000000000000000000000000000011111111111100001011110111000001
1101 << 0010=0100
1101 >>_a 0010=1111
1101 >>_l 0010=0011
1001 /_s 0010 =1101
1001 /_u 0010 =0100
0111 %_s 0011 =0001 (1) 
0111 %_s 1101 =0001 (1) 
1001 %_s 0011 =1111 (-1) 
1001 %_s 1101 =1111 (-1) 
0111 %_u 0011 =0001
0111 %_u 1101 =0111
1001 %_s 0011 =0000
1001 %_s 1101 =1001
entry:
  y = -10;
  havoc(nd);
  goto bb_nd;
bb_nd:
  goto bb_nd_tt,bb_nd_ff;
bb_nd_tt:
  assume(-nd <= -1);
  x = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(-x+y <= 0);
  goto bb2;
bb2:
  x = x-y;
  goto bb1;
bb1_f:
  assume(x-y <= -1);
  goto ret;
ret:

bb_nd_ff:
  assume(nd <= 0);
  x = 100;
  goto bb1;

Invariants using Intervals
entry={}
bb_nd={y -> [-10, -10]}
bb_nd_ff={y -> [-10, -10]}
bb1={x -> [0, +oo]; y -> [-10, -10]}
bb1_f={x -> [0, +oo]; y -> [-10, -10]}
ret=_|_
bb1_t={x -> [0, +oo]; y -> [-10, -10]}
bb2={x -> [0, +oo]; y -> [-10, -10]}
bb_nd_tt={y -> [-10, -10]}
Abstract trace: entry bb_nd bb_nd_ff bb_nd_tt (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using WrappedIntervals
entry={}
bb_nd={y -> [[-10, -10]]_8}
bb_nd_ff={y -> [[-10, -10]]_8}
bb1={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
bb1_f={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
ret={x -> [[-128, -119]]_8; y -> [[-10, -10]]_8}
bb1_t={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
bb2={x -> [[0, 127]]_8; y -> [[-10, -10]]_8}
bb_nd_tt={y -> [[-10, -10]]_8}
Abstract trace: entry bb_nd bb_nd_ff bb_nd_tt (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  x = 127;
  x = x+1;
  goto if,then;
if:
  assume(x <= 1);
  x = 10;
  goto ret;
ret:

then:
  assume(-x <= -2);
  x = -10;
  goto ret;

Invariants using WrappedIntervals
entry={}
then={x -> [[-128, -128]]_8}
ret={x -> [[10, 10]]_8}
if={x -> [[-128, -128]]_8}
Abstract trace: entry then if ret

entry:
  x = 127;
  x = x+1;
  goto if,then;
if:
  assume(x <=_u 1);
  x = 10;
  goto ret;
ret:

then:
  assume(-x <=_u -2);
  x = -10;
  goto ret;

Invariants using WrappedIntervals
entry={}
then={x -> [[-128, -128]]_8}
ret={x -> [[-10, -10]]_8}
if={x -> [[-128, -128]]_8}
Abstract trace: entry then if ret

i1=[[-10, 10]]_8
i2=[[0, 20]]_8
-i2=[[-20, 0]]_8
i1 & i2: [[0, 10]]_8
i1 | i2: [[-10, 20]]_8
[[0, -10]]_8 & [[-15, 5]]_8: [[-15, 5]]_8
[[0, -10]]_8 | [[-15, 5]]_8: top
urk: [[1642571628, 700177772]]_32
urk.is_top(): 0
urk == Top: 0
[[-1, -7]]_4 * [[0, 1]]_4 = [[-1, -7]]_4
[[4, 7]]_4 /_s [[-2, 3]]_4 = [[1, -2]]_4
[[4, 7]]_4 /_u [[-2, 3]]_4 = [[0, 7]]_4
[[4, 7]]_4 /_s [[2, 2]]_4 = [[2, 3]]_4
[[4, 7]]_4 /_u [[2, 2]]_4 = [[2, 3]]_4
